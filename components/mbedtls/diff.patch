From 2a2bc56cd739af4f760942528fc7eef63eebec14 Mon Sep 17 00:00:00 2001
From: Andy Green <andy@warmcat.com>
Date: Tue, 12 Dec 2017 11:07:23 +0800
Subject: [PATCH 1/4] dynamic content length: unify context ssl record members

This patch simplifies the 21 members currently in mbedtls_ssl_context
for in and out, to instead use a new struct of 11 members, twice.

This patch just does the conversion without adding or changing any code or
behaviours outside that.

This should not impact code size since the structs are composed into the context
struct.  Struct packing won't be affected any more than the original version, which
also mixes pointers and ints.

In later patches this change is used to allow dynamic management of in and out
buffer sizes indepenendently, without needing special code between in and out
related members.

.in_offt is included in the common struct despite only existing for the in
record stuff, because it will also need fixing up if the buffer size
changes.

Signed-off-by: Andy Green <andy@warmcat.com>
---
 include/mbedtls/ssl.h                |  59 ++-
 include/mbedtls/ssl_internal.h       |  16 +-
 library/ssl_cli.c                    | 120 ++---
 library/ssl_srv.c                    | 130 ++---
 library/ssl_tls.c                    | 919 ++++++++++++++++++-----------------
 tests/suites/test_suite_ssl.function |   6 +-
 6 files changed, 650 insertions(+), 600 deletions(-)

diff --git a/include/mbedtls/ssl.h b/include/mbedtls/ssl.h
index e98101e19..ead330310 100644
--- a/include/mbedtls/ssl.h
+++ b/include/mbedtls/ssl.h
@@ -207,6 +207,16 @@
 #define MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME     86400 /**< Lifetime of session tickets (if enabled) */
 #endif
 
+/*
+ * The default minimum allocation for fragment buffers.
+ * Making it larger trades off memory against the number of
+ * reallocations needed to make it big enough for cases where
+ * it needs to be bigger
+ */
+#if !defined(MBEDTLS_SSL_BUFFER_MIN)
+#define MBEDTLS_SSL_BUFFER_MIN 512
+#endif
+
 /*
  * Maxium fragment length in bytes,
  * determines the size of each of the two internal I/O buffers.
@@ -530,6 +540,7 @@ typedef int mbedtls_ssl_get_timer_t( void * ctx );
 typedef struct mbedtls_ssl_session mbedtls_ssl_session;
 typedef struct mbedtls_ssl_context mbedtls_ssl_context;
 typedef struct mbedtls_ssl_config  mbedtls_ssl_config;
+typedef struct mbedtls_ssl_record  mbedtls_ssl_record;
 
 /* Defined in ssl_internal.h */
 typedef struct mbedtls_ssl_transform mbedtls_ssl_transform;
@@ -759,6 +770,27 @@ struct mbedtls_ssl_config
 #endif
 };
 
+struct mbedtls_ssl_record
+{
+    unsigned char *buf;      /*!< buffer                     */
+
+    /* pointers into buf */
+    unsigned char *ctr;      /*!< 64-bit incoming message counter
+                                     TLS: maintained by us
+                                     DTLS: read from peer             */
+    unsigned char *hdr;      /*!< start of record header           */
+    unsigned char *len;      /*!< two-bytes message length field   */
+    unsigned char *iv;       /*!< ivlen-byte IV                    */
+    unsigned char *msg;      /*!< message contents (in_iv+ivlen)   */
+
+    unsigned char *offt;     /*!< in only read offset in application data  */
+
+    int msgtype;             /*!< record header: message type      */
+    size_t msglen;           /*!< record header: message length    */
+    size_t left;             /*!< amount of data read so far       */
+    uint16_t max_content_len; /*!< allocated size of .buf, minus
+                                   MBEDTLS_SSL_BUFFER_OVERHEAD */
+};
 
 struct mbedtls_ssl_context
 {
@@ -819,19 +851,9 @@ struct mbedtls_ssl_context
     /*
      * Record layer (incoming data)
      */
-    unsigned char *in_buf;      /*!< input buffer                     */
-    unsigned char *in_ctr;      /*!< 64-bit incoming message counter
-                                     TLS: maintained by us
-                                     DTLS: read from peer             */
-    unsigned char *in_hdr;      /*!< start of record header           */
-    unsigned char *in_len;      /*!< two-bytes message length field   */
-    unsigned char *in_iv;       /*!< ivlen-byte IV                    */
-    unsigned char *in_msg;      /*!< message contents (in_iv+ivlen)   */
-    unsigned char *in_offt;     /*!< read offset in application data  */
-
-    int in_msgtype;             /*!< record header: message type      */
-    size_t in_msglen;           /*!< record header: message length    */
-    size_t in_left;             /*!< amount of data read so far       */
+
+    mbedtls_ssl_record in;
+
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     uint16_t in_epoch;          /*!< DTLS epoch for incoming records  */
     size_t next_record_offset;  /*!< offset of the next record in datagram
@@ -852,16 +874,7 @@ struct mbedtls_ssl_context
     /*
      * Record layer (outgoing data)
      */
-    unsigned char *out_buf;     /*!< output buffer                    */
-    unsigned char *out_ctr;     /*!< 64-bit outgoing message counter  */
-    unsigned char *out_hdr;     /*!< start of record header           */
-    unsigned char *out_len;     /*!< two-bytes message length field   */
-    unsigned char *out_iv;      /*!< ivlen-byte IV                    */
-    unsigned char *out_msg;     /*!< message contents (out_iv+ivlen)  */
-
-    int out_msgtype;            /*!< record header: message type      */
-    size_t out_msglen;          /*!< record header: message length    */
-    size_t out_left;            /*!< amount of data not yet written   */
+    mbedtls_ssl_record out;
 
 #if defined(MBEDTLS_ZLIB_SUPPORT)
     unsigned char *compress_buf;        /*!<  zlib data buffer        */
diff --git a/include/mbedtls/ssl_internal.h b/include/mbedtls/ssl_internal.h
index 756360b18..2e83e24a2 100644
--- a/include/mbedtls/ssl_internal.h
+++ b/include/mbedtls/ssl_internal.h
@@ -138,13 +138,13 @@
 #define MBEDTLS_SSL_PADDING_ADD              0
 #endif
 
-#define MBEDTLS_SSL_BUFFER_LEN  ( MBEDTLS_SSL_MAX_CONTENT_LEN               \
-                        + MBEDTLS_SSL_COMPRESSION_ADD               \
-                        + 29 /* counter + header + IV */    \
-                        + MBEDTLS_SSL_MAC_ADD                       \
-                        + MBEDTLS_SSL_PADDING_ADD                   \
-                        )
+#define MBEDTLS_SSL_BUFFER_OVERHEAD  (                         \
+                        + MBEDTLS_SSL_COMPRESSION_ADD          \
+                        + 29 /* counter + header + IV */       \
+                        + MBEDTLS_SSL_MAC_ADD                  \
+                        + MBEDTLS_SSL_PADDING_ADD )
 
+#define MBEDTLS_SSL_BUFFER_LEN  ( MBEDTLS_SSL_MAX_CONTENT_LEN + MBEDTLS_SSL_BUFFER_OVERHEAD )
 /*
  * TLS extension flags (for extensions with outgoing ServerHello content
  * that need it (e.g. for RENEGOTIATION_INFO the server already knows because
@@ -596,6 +596,10 @@ int mbedtls_ssl_dtls_replay_check( mbedtls_ssl_context *ssl );
 void mbedtls_ssl_dtls_replay_update( mbedtls_ssl_context *ssl );
 #endif
 
+int mbedtls_ssl_alloc_record_buf( mbedtls_ssl_context *ssl,
+                                  mbedtls_ssl_record *rec,
+                                  size_t max_content_len );
+
 /* constant-time buffer comparison */
 static inline int mbedtls_ssl_safer_memcmp( const void *a, const void *b, size_t n )
 {
diff --git a/library/ssl_cli.c b/library/ssl_cli.c
index 554348f1b..b19449abd 100644
--- a/library/ssl_cli.c
+++ b/library/ssl_cli.c
@@ -60,7 +60,7 @@ static void ssl_write_hostname_ext( mbedtls_ssl_context *ssl,
                                     size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     size_t hostname_len;
 
     *olen = 0;
@@ -130,7 +130,7 @@ static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,
                                          size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 
     *olen = 0;
 
@@ -174,7 +174,7 @@ static void ssl_write_signature_algorithms_ext( mbedtls_ssl_context *ssl,
                                                 size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     size_t sig_alg_len = 0;
     const int *md;
 #if defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C)
@@ -259,7 +259,7 @@ static void ssl_write_supported_elliptic_curves_ext( mbedtls_ssl_context *ssl,
                                                      size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     unsigned char *elliptic_curve_list = p + 6;
     size_t elliptic_curve_len = 0;
     const mbedtls_ecp_curve_info *info;
@@ -332,7 +332,7 @@ static void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,
                                                    size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 
     *olen = 0;
 
@@ -365,7 +365,7 @@ static void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
 {
     int ret;
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     size_t kkpp_len;
 
     *olen = 0;
@@ -442,7 +442,7 @@ static void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
                                                size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 
     *olen = 0;
 
@@ -475,7 +475,7 @@ static void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,
                                           unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 
     *olen = 0;
 
@@ -507,7 +507,7 @@ static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
                                        unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 
     *olen = 0;
 
@@ -541,7 +541,7 @@ static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                        unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 
     *olen = 0;
 
@@ -575,7 +575,7 @@ static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                           unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     size_t tlen = ssl->session_negotiate->ticket_len;
 
     *olen = 0;
@@ -619,7 +619,7 @@ static void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
                                 unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     size_t alpnlen = 0;
     const char **cur;
 
@@ -757,7 +757,7 @@ static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
      *     6  .   9   current UNIX time
      *    10  .  37   random bytes
      */
-    buf = ssl->out_msg;
+    buf = ssl->out.msg;
     p = buf + 4;
 
     mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,
@@ -1044,9 +1044,9 @@ static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
         p += ext_len;
     }
 
-    ssl->out_msglen  = p - buf;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_HELLO;
+    ssl->out.msglen  = p - buf;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_CLIENT_HELLO;
 
     ssl->state++;
 
@@ -1369,7 +1369,7 @@ static int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
 static int ssl_parse_hello_verify_request( mbedtls_ssl_context *ssl )
 {
-    const unsigned char *p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
+    const unsigned char *p = ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl );
     int major_ver, minor_ver;
     unsigned char cookie_len;
 
@@ -1405,7 +1405,7 @@ static int ssl_parse_hello_verify_request( mbedtls_ssl_context *ssl )
     cookie_len = *p++;
     MBEDTLS_SSL_DEBUG_BUF( 3, "cookie", p, cookie_len );
 
-    if( ( ssl->in_msg + ssl->in_msglen ) - p < cookie_len )
+    if( ( ssl->in.msg + ssl->in.msglen ) - p < cookie_len )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1,
             ( "cookie length does not match incoming message size" ) );
@@ -1456,7 +1456,7 @@ static int ssl_parse_server_hello( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse server hello" ) );
 
-    buf = ssl->in_msg;
+    buf = ssl->in.msg;
 
     if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
     {
@@ -1465,7 +1465,7 @@ static int ssl_parse_server_hello( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
 #if defined(MBEDTLS_SSL_RENEGOTIATION)
         if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
@@ -2134,7 +2134,7 @@ static int ssl_write_encrypted_pms( mbedtls_ssl_context *ssl,
 
     if( ( ret = mbedtls_pk_encrypt( &ssl->session_negotiate->peer_cert->pk,
                             p, ssl->handshake->pmslen,
-                            ssl->out_msg + offset + len_bytes, olen,
+                            ssl->out.msg + offset + len_bytes, olen,
                             MBEDTLS_SSL_MAX_CONTENT_LEN - offset - len_bytes,
                             ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
     {
@@ -2146,8 +2146,8 @@ static int ssl_write_encrypted_pms( mbedtls_ssl_context *ssl,
     defined(MBEDTLS_SSL_PROTO_TLS1_2)
     if( len_bytes == 2 )
     {
-        ssl->out_msg[offset+0] = (unsigned char)( *olen >> 8 );
-        ssl->out_msg[offset+1] = (unsigned char)( *olen      );
+        ssl->out.msg[offset+0] = (unsigned char)( *olen >> 8 );
+        ssl->out.msg[offset+1] = (unsigned char)( *olen      );
         *olen += 2;
     }
 #endif
@@ -2309,7 +2309,7 @@ static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -2321,7 +2321,7 @@ static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )
      * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server
      * doesn't use a psk_identity_hint
      */
-    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )
+    if( ssl->in.msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )
     {
         if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
             ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
@@ -2340,8 +2340,8 @@ static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
-    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
-    end = ssl->in_msg + ssl->in_hslen;
+    p   = ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl );
+    end = ssl->in.msg + ssl->in_hslen;
     MBEDTLS_SSL_DEBUG_BUF( 3,   "server key exchange", p, end - p );
 
 #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
@@ -2430,7 +2430,7 @@ static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )
         unsigned char hash[64];
         mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
         mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
-        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
+        unsigned char *params = ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl );
         size_t params_len = p - params;
 
         /*
@@ -2660,7 +2660,7 @@ static int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate request message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -2669,7 +2669,7 @@ static int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )
     }
 
     ssl->state++;
-    ssl->client_auth = ( ssl->in_msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST );
+    ssl->client_auth = ( ssl->in.msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "got %s certificate request",
                         ssl->client_auth ? "a" : "no" ) );
@@ -2705,7 +2705,7 @@ static int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )
      *  However, we still minimally parse the message to check it is at least
      *  superficially sane.
      */
-    buf = ssl->in_msg;
+    buf = ssl->in.msg;
 
     /* certificate_types */
     cert_type_len = buf[mbedtls_ssl_hs_hdr_len( ssl )];
@@ -2780,14 +2780,14 @@ static int ssl_parse_server_hello_done( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello done message" ) );
         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
     if( ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ||
-        ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE )
+        ssl->in.msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server hello done message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -2824,13 +2824,13 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
          */
         n = ssl->handshake->dhm_ctx.len;
 
-        ssl->out_msg[4] = (unsigned char)( n >> 8 );
-        ssl->out_msg[5] = (unsigned char)( n      );
+        ssl->out.msg[4] = (unsigned char)( n >> 8 );
+        ssl->out.msg[5] = (unsigned char)( n      );
         i = 6;
 
         ret = mbedtls_dhm_make_public( &ssl->handshake->dhm_ctx,
                                 (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),
-                               &ssl->out_msg[i], n,
+                               &ssl->out.msg[i], n,
                                 ssl->conf->f_rng, ssl->conf->p_rng );
         if( ret != 0 )
         {
@@ -2871,7 +2871,7 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
 
         ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx,
                                 &n,
-                                &ssl->out_msg[i], 1000,
+                                &ssl->out.msg[i], 1000,
                                 ssl->conf->f_rng, ssl->conf->p_rng );
         if( ret != 0 )
         {
@@ -2920,10 +2920,10 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
             return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
         }
 
-        ssl->out_msg[i++] = (unsigned char)( n >> 8 );
-        ssl->out_msg[i++] = (unsigned char)( n      );
+        ssl->out.msg[i++] = (unsigned char)( n >> 8 );
+        ssl->out.msg[i++] = (unsigned char)( n      );
 
-        memcpy( ssl->out_msg + i, ssl->conf->psk_identity, ssl->conf->psk_identity_len );
+        memcpy( ssl->out.msg + i, ssl->conf->psk_identity, ssl->conf->psk_identity_len );
         i += ssl->conf->psk_identity_len;
 
 #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
@@ -2956,12 +2956,12 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
                 return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
             }
 
-            ssl->out_msg[i++] = (unsigned char)( n >> 8 );
-            ssl->out_msg[i++] = (unsigned char)( n      );
+            ssl->out.msg[i++] = (unsigned char)( n >> 8 );
+            ssl->out.msg[i++] = (unsigned char)( n      );
 
             ret = mbedtls_dhm_make_public( &ssl->handshake->dhm_ctx,
                     (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),
-                    &ssl->out_msg[i], n,
+                    &ssl->out.msg[i], n,
                     ssl->conf->f_rng, ssl->conf->p_rng );
             if( ret != 0 )
             {
@@ -2978,7 +2978,7 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
              * ClientECDiffieHellmanPublic public;
              */
             ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx, &n,
-                    &ssl->out_msg[i], MBEDTLS_SSL_MAX_CONTENT_LEN - i,
+                    &ssl->out.msg[i], MBEDTLS_SSL_MAX_CONTENT_LEN - i,
                     ssl->conf->f_rng, ssl->conf->p_rng );
             if( ret != 0 )
             {
@@ -3019,7 +3019,7 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
         i = 4;
 
         ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
-                ssl->out_msg + i, MBEDTLS_SSL_MAX_CONTENT_LEN - i, &n,
+                ssl->out.msg + i, MBEDTLS_SSL_MAX_CONTENT_LEN - i, &n,
                 ssl->conf->f_rng, ssl->conf->p_rng );
         if( ret != 0 )
         {
@@ -3044,9 +3044,9 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
     }
 
-    ssl->out_msglen  = i + n;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE;
+    ssl->out.msglen  = i + n;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE;
 
     ssl->state++;
 
@@ -3198,14 +3198,14 @@ static int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )
             MBEDTLS_MD_SHA384 )
         {
             md_alg = MBEDTLS_MD_SHA384;
-            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA384;
+            ssl->out.msg[4] = MBEDTLS_SSL_HASH_SHA384;
         }
         else
         {
             md_alg = MBEDTLS_MD_SHA256;
-            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;
+            ssl->out.msg[4] = MBEDTLS_SSL_HASH_SHA256;
         }
-        ssl->out_msg[5] = mbedtls_ssl_sig_from_pk( mbedtls_ssl_own_key( ssl ) );
+        ssl->out.msg[5] = mbedtls_ssl_sig_from_pk( mbedtls_ssl_own_key( ssl ) );
 
         /* Info from md_alg will be used instead */
         hashlen = 0;
@@ -3219,19 +3219,19 @@ static int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )
     }
 
     if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash_start, hashlen,
-                         ssl->out_msg + 6 + offset, &n,
+                         ssl->out.msg + 6 + offset, &n,
                          ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_sign", ret );
         return( ret );
     }
 
-    ssl->out_msg[4 + offset] = (unsigned char)( n >> 8 );
-    ssl->out_msg[5 + offset] = (unsigned char)( n      );
+    ssl->out.msg[4 + offset] = (unsigned char)( n >> 8 );
+    ssl->out.msg[5 + offset] = (unsigned char)( n      );
 
-    ssl->out_msglen  = 6 + n + offset;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_VERIFY;
+    ssl->out.msglen  = 6 + n + offset;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_VERIFY;
 
     ssl->state++;
 
@@ -3269,7 +3269,7 @@ static int ssl_parse_new_session_ticket( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -3287,7 +3287,7 @@ static int ssl_parse_new_session_ticket( mbedtls_ssl_context *ssl )
      * 4  .  5   ticket_len (n)
      * 6  .  5+n ticket content
      */
-    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||
+    if( ssl->in.msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||
         ssl->in_hslen < 6 + mbedtls_ssl_hs_hdr_len( ssl ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad new session ticket message" ) );
@@ -3296,7 +3296,7 @@ static int ssl_parse_new_session_ticket( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET );
     }
 
-    msg = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
+    msg = ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl );
 
     lifetime = ( msg[0] << 24 ) | ( msg[1] << 16 ) |
                ( msg[2] <<  8 ) | ( msg[3]       );
diff --git a/library/ssl_srv.c b/library/ssl_srv.c
index 37f415dd1..5875f3071 100644
--- a/library/ssl_srv.c
+++ b/library/ssl_srv.c
@@ -917,7 +917,7 @@ static int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )
     }
 #endif /* MBEDTLS_SSL_RENEGOTIATION */
 
-    buf = ssl->in_hdr;
+    buf = ssl->in.hdr;
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, 5 );
 
@@ -980,8 +980,8 @@ static int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )
 
     ssl->handshake->update_checksum( ssl, buf + 2, n );
 
-    buf = ssl->in_msg;
-    n = ssl->in_left - 5;
+    buf = ssl->in.msg;
+    n = ssl->in.left - 5;
 
     /*
      *    0  .   1   ciphersuitelist length
@@ -1148,7 +1148,7 @@ static int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
     }
 
-    ssl->in_left = 0;
+    ssl->in.left = 0;
     ssl->state++;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello v2" ) );
@@ -1209,7 +1209,7 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
         }
     }
 
-    buf = ssl->in_hdr;
+    buf = ssl->in.hdr;
 
 #if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
@@ -1240,7 +1240,7 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
     }
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message len.: %d",
-                   ( ssl->in_len[0] << 8 ) | ssl->in_len[1] ) );
+                   ( ssl->in.len[0] << 8 ) | ssl->in.len[1] ) );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, protocol version: [%d:%d]",
                    buf[1], buf[2] ) );
@@ -1267,20 +1267,20 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
         )
     {
         /* Epoch should be 0 for initial handshakes */
-        if( ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0 )
+        if( ssl->in.ctr[0] != 0 || ssl->in.ctr[1] != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
             return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
         }
 
-        memcpy( ssl->out_ctr + 2, ssl->in_ctr + 2, 6 );
+        memcpy( ssl->out.ctr + 2, ssl->in.ctr + 2, 6 );
 
 #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
         if( mbedtls_ssl_dtls_replay_check( ssl ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "replayed record, discarding" ) );
             ssl->next_record_offset = 0;
-            ssl->in_left = 0;
+            ssl->in.left = 0;
             goto read_record_header;
         }
 
@@ -1290,7 +1290,7 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
     }
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
 
-    msg_len = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
+    msg_len = ( ssl->in.len[0] << 8 ) | ssl->in.len[1];
 
 #if defined(MBEDTLS_SSL_RENEGOTIATION)
     if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
@@ -1320,10 +1320,10 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
             ssl->next_record_offset = msg_len + mbedtls_ssl_hdr_len( ssl );
         else
 #endif
-            ssl->in_left = 0;
+            ssl->in.left = 0;
     }
 
-    buf = ssl->in_msg;
+    buf = ssl->in.msg;
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, msg_len );
 
@@ -1373,8 +1373,8 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
         if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
         {
             /* This couldn't be done in ssl_prepare_handshake_record() */
-            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
-                                         ssl->in_msg[5];
+            unsigned int cli_msg_seq = ( ssl->in.msg[4] << 8 ) |
+                                         ssl->in.msg[5];
 
             if( cli_msg_seq != ssl->handshake->in_msg_seq )
             {
@@ -1389,8 +1389,8 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
         else
 #endif
         {
-            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
-                                         ssl->in_msg[5];
+            unsigned int cli_msg_seq = ( ssl->in.msg[4] << 8 ) |
+                                         ssl->in.msg[5];
             ssl->handshake->out_msg_seq = cli_msg_seq;
             ssl->handshake->in_msg_seq  = cli_msg_seq + 1;
         }
@@ -1399,8 +1399,8 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
          * For now we don't support fragmentation, so make sure
          * fragment_offset == 0 and fragment_length == length
          */
-        if( ssl->in_msg[6] != 0 || ssl->in_msg[7] != 0 || ssl->in_msg[8] != 0 ||
-            memcmp( ssl->in_msg + 1, ssl->in_msg + 9, 3 ) != 0 )
+        if( ssl->in.msg[6] != 0 || ssl->in.msg[7] != 0 || ssl->in.msg[8] != 0 ||
+            memcmp( ssl->in.msg + 1, ssl->in.msg + 9, 3 ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "ClientHello fragmentation not supported" ) );
             return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
@@ -2233,7 +2233,7 @@ static void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
 {
     int ret;
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     size_t kkpp_len;
 
     *olen = 0;
@@ -2310,7 +2310,7 @@ static void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
 static int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
 {
     int ret;
-    unsigned char *p = ssl->out_msg + 4;
+    unsigned char *p = ssl->out.msg + 4;
     unsigned char *cookie_len_byte;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello verify request" ) );
@@ -2340,7 +2340,7 @@ static int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
     cookie_len_byte = p++;
 
     if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,
-                                     &p, ssl->out_buf + MBEDTLS_SSL_BUFFER_LEN,
+                                     &p, ssl->out.buf + MBEDTLS_SSL_BUFFER_LEN,
                                      ssl->cli_id, ssl->cli_id_len ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "f_cookie_write", ret );
@@ -2351,9 +2351,9 @@ static int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_BUF( 3, "cookie sent", cookie_len_byte + 1, *cookie_len_byte );
 
-    ssl->out_msglen  = p - ssl->out_msg;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
+    ssl->out.msglen  = p - ssl->out.msg;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
 
     ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
 
@@ -2404,7 +2404,7 @@ static int ssl_write_server_hello( mbedtls_ssl_context *ssl )
      *     6  .   9   UNIX time()
      *    10  .  37   random bytes
      */
-    buf = ssl->out_msg;
+    buf = ssl->out.msg;
     p = buf + 4;
 
     mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
@@ -2589,9 +2589,9 @@ static int ssl_write_server_hello( mbedtls_ssl_context *ssl )
     }
 #endif
 
-    ssl->out_msglen  = p - buf;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
+    ssl->out.msglen  = p - buf;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
 
     ret = mbedtls_ssl_write_record( ssl );
 
@@ -2636,7 +2636,7 @@ static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
     size_t dn_size, total_dn_size; /* excluding length bytes */
     size_t ct_len, sa_len; /* including length bytes */
     unsigned char *buf, *p;
-    const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char * const end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
     const mbedtls_x509_crt *crt;
     int authmode;
 
@@ -2674,7 +2674,7 @@ static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
      *    n+4 .. ...  Distinguished Name #1
      *    ... .. ...  length of DN 2, etc.
      */
-    buf = ssl->out_msg;
+    buf = ssl->out.msg;
     p = buf + 4;
 
     /*
@@ -2782,11 +2782,11 @@ static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
         }
     }
 
-    ssl->out_msglen  = p - buf;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
-    ssl->out_msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );
-    ssl->out_msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );
+    ssl->out.msglen  = p - buf;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
+    ssl->out.msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );
+    ssl->out.msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );
 
     ret = mbedtls_ssl_write_record( ssl );
 
@@ -2834,7 +2834,7 @@ static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
                             ssl->transform_negotiate->ciphersuite_info;
 
 #if defined(MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED)
-    unsigned char *p = ssl->out_msg + 4;
+    unsigned char *p = ssl->out.msg + 4;
     size_t len;
 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
     unsigned char *dig_signed = p;
@@ -2883,7 +2883,7 @@ static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
     {
-        const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+        const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
 
         ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
                 p, end - p, &len, ssl->conf->f_rng, ssl->conf->p_rng );
@@ -3227,9 +3227,9 @@ static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
 
     /* Done with actual work; add header and send. */
 
-    ssl->out_msglen  = 4 + n;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;
+    ssl->out.msglen  = 4 + n;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;
 
     ssl->state++;
 
@@ -3250,9 +3250,9 @@ static int ssl_write_server_hello_done( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello done" ) );
 
-    ssl->out_msglen  = 4;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;
+    ssl->out.msglen  = 4;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;
 
     ssl->state++;
 
@@ -3494,16 +3494,16 @@ static int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
-    end = ssl->in_msg + ssl->in_hslen;
+    p = ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl );
+    end = ssl->in.msg + ssl->in_hslen;
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
     }
 
-    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )
+    if( ssl->in.msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
@@ -3806,8 +3806,8 @@ static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
     ssl->state++;
 
     /* Process the message contents */
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
-        ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
+        ssl->in.msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
         return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
@@ -3852,9 +3852,9 @@ static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
         /*
          * Hash
          */
-        md_alg = mbedtls_ssl_md_alg_from_hash( ssl->in_msg[i] );
+        md_alg = mbedtls_ssl_md_alg_from_hash( ssl->in.msg[i] );
 
-        if( md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md( ssl, ssl->in_msg[i] ) )
+        if( md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md( ssl, ssl->in.msg[i] ) )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
                                 " for verify message" ) );
@@ -3874,7 +3874,7 @@ static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
         /*
          * Signature
          */
-        if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in_msg[i] ) )
+        if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in.msg[i] ) )
                         == MBEDTLS_PK_NONE )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
@@ -3906,7 +3906,7 @@ static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
     }
 
-    sig_len = ( ssl->in_msg[i] << 8 ) | ssl->in_msg[i+1];
+    sig_len = ( ssl->in.msg[i] << 8 ) | ssl->in.msg[i+1];
     i += 2;
 
     if( i + sig_len != ssl->in_hslen )
@@ -3920,7 +3920,7 @@ static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
 
     if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,
                            md_alg, hash_start, hashlen,
-                           ssl->in_msg + i, sig_len ) ) != 0 )
+                           ssl->in.msg + i, sig_len ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_verify", ret );
         return( ret );
@@ -3948,8 +3948,8 @@ static int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write new session ticket" ) );
 
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
 
     /*
      * struct {
@@ -3964,23 +3964,23 @@ static int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
 
     if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,
                                 ssl->session_negotiate,
-                                ssl->out_msg + 10,
-                                ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN,
+                                ssl->out.msg + 10,
+                                ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN,
                                 &tlen, &lifetime ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_write", ret );
         tlen = 0;
     }
 
-    ssl->out_msg[4] = ( lifetime >> 24 ) & 0xFF;
-    ssl->out_msg[5] = ( lifetime >> 16 ) & 0xFF;
-    ssl->out_msg[6] = ( lifetime >>  8 ) & 0xFF;
-    ssl->out_msg[7] = ( lifetime       ) & 0xFF;
+    ssl->out.msg[4] = ( lifetime >> 24 ) & 0xFF;
+    ssl->out.msg[5] = ( lifetime >> 16 ) & 0xFF;
+    ssl->out.msg[6] = ( lifetime >>  8 ) & 0xFF;
+    ssl->out.msg[7] = ( lifetime       ) & 0xFF;
 
-    ssl->out_msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );
-    ssl->out_msg[9] = (unsigned char)( ( tlen      ) & 0xFF );
+    ssl->out.msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );
+    ssl->out.msg[9] = (unsigned char)( ( tlen      ) & 0xFF );
 
-    ssl->out_msglen = 10 + tlen;
+    ssl->out.msglen = 10 + tlen;
 
     /*
      * Morally equivalent to updating ssl->state, but NewSessionTicket and
diff --git a/library/ssl_tls.c b/library/ssl_tls.c
index 2690e4673..e6a5e83cc 100644
--- a/library/ssl_tls.c
+++ b/library/ssl_tls.c
@@ -1266,7 +1266,7 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
     mode = mbedtls_cipher_get_cipher_mode( &ssl->transform_out->cipher_ctx_enc );
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "before encrypt: output payload",
-                      ssl->out_msg, ssl->out_msglen );
+                      ssl->out.msg, ssl->out.msglen );
 
     /*
      * Add MAC before if needed
@@ -1284,8 +1284,8 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
         {
             ssl_mac( &ssl->transform_out->md_ctx_enc,
                       ssl->transform_out->mac_enc,
-                      ssl->out_msg, ssl->out_msglen,
-                      ssl->out_ctr, ssl->out_msgtype );
+                      ssl->out.msg, ssl->out.msglen,
+                      ssl->out.ctr, ssl->out.msgtype );
         }
         else
 #endif
@@ -1293,13 +1293,13 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
         defined(MBEDTLS_SSL_PROTO_TLS1_2)
         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
         {
-            mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_ctr, 8 );
-            mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_hdr, 3 );
-            mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_len, 2 );
+            mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out.ctr, 8 );
+            mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out.hdr, 3 );
+            mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out.len, 2 );
             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc,
-                             ssl->out_msg, ssl->out_msglen );
+                             ssl->out.msg, ssl->out.msglen );
             mbedtls_md_hmac_finish( &ssl->transform_out->md_ctx_enc,
-                             ssl->out_msg + ssl->out_msglen );
+                             ssl->out.msg + ssl->out.msglen );
             mbedtls_md_hmac_reset( &ssl->transform_out->md_ctx_enc );
         }
         else
@@ -1310,10 +1310,10 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
         }
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "computed mac",
-                       ssl->out_msg + ssl->out_msglen,
+                       ssl->out.msg + ssl->out.msglen,
                        ssl->transform_out->maclen );
 
-        ssl->out_msglen += ssl->transform_out->maclen;
+        ssl->out.msglen += ssl->transform_out->maclen;
         auth_done++;
     }
 #endif /* AEAD not the only option */
@@ -1329,19 +1329,19 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
 
         MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
                             "including %d bytes of padding",
-                       ssl->out_msglen, 0 ) );
+                       ssl->out.msglen, 0 ) );
 
         if( ( ret = mbedtls_cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
                                    ssl->transform_out->iv_enc,
                                    ssl->transform_out->ivlen,
-                                   ssl->out_msg, ssl->out_msglen,
-                                   ssl->out_msg, &olen ) ) != 0 )
+                                   ssl->out.msg, ssl->out.msglen,
+                                   ssl->out.msg, &olen ) ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
             return( ret );
         }
 
-        if( ssl->out_msglen != olen )
+        if( ssl->out.msglen != olen )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
@@ -1360,12 +1360,12 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
         unsigned char taglen = ssl->transform_out->ciphersuite_info->flags &
                                MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16;
 
-        memcpy( add_data, ssl->out_ctr, 8 );
-        add_data[8]  = ssl->out_msgtype;
+        memcpy( add_data, ssl->out.ctr, 8 );
+        add_data[8]  = ssl->out.msgtype;
         mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
                            ssl->conf->transport, add_data + 9 );
-        add_data[11] = ( ssl->out_msglen >> 8 ) & 0xFF;
-        add_data[12] = ssl->out_msglen & 0xFF;
+        add_data[11] = ( ssl->out.msglen >> 8 ) & 0xFF;
+        add_data[12] = ssl->out.msglen & 0xFF;
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
                        add_data, 13 );
@@ -1381,23 +1381,23 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
         }
 
         memcpy( ssl->transform_out->iv_enc + ssl->transform_out->fixed_ivlen,
-                             ssl->out_ctr, 8 );
-        memcpy( ssl->out_iv, ssl->out_ctr, 8 );
+                             ssl->out.ctr, 8 );
+        memcpy( ssl->out.iv, ssl->out.ctr, 8 );
 
-        MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", ssl->out_iv,
+        MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", ssl->out.iv,
                 ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen );
 
         /*
          * Fix pointer positions and message length with added IV
          */
-        enc_msg = ssl->out_msg;
-        enc_msglen = ssl->out_msglen;
-        ssl->out_msglen += ssl->transform_out->ivlen -
+        enc_msg = ssl->out.msg;
+        enc_msglen = ssl->out.msglen;
+        ssl->out.msglen += ssl->transform_out->ivlen -
                            ssl->transform_out->fixed_ivlen;
 
         MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
                             "including %d bytes of padding",
-                       ssl->out_msglen, 0 ) );
+                       ssl->out.msglen, 0 ) );
 
         /*
          * Encrypt and authenticate
@@ -1420,7 +1420,7 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
         }
 
-        ssl->out_msglen += taglen;
+        ssl->out.msglen += taglen;
         auth_done++;
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "after encrypt: tag", enc_msg + enc_msglen, taglen );
@@ -1435,18 +1435,18 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
         unsigned char *enc_msg;
         size_t enc_msglen, padlen, olen = 0, i;
 
-        padlen = ssl->transform_out->ivlen - ( ssl->out_msglen + 1 ) %
+        padlen = ssl->transform_out->ivlen - ( ssl->out.msglen + 1 ) %
                  ssl->transform_out->ivlen;
         if( padlen == ssl->transform_out->ivlen )
             padlen = 0;
 
         for( i = 0; i <= padlen; i++ )
-            ssl->out_msg[ssl->out_msglen + i] = (unsigned char) padlen;
+            ssl->out.msg[ssl->out.msglen + i] = (unsigned char) padlen;
 
-        ssl->out_msglen += padlen + 1;
+        ssl->out.msglen += padlen + 1;
 
-        enc_msglen = ssl->out_msglen;
-        enc_msg = ssl->out_msg;
+        enc_msglen = ssl->out.msglen;
+        enc_msg = ssl->out.msg;
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
         /*
@@ -1463,21 +1463,21 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
             if( ret != 0 )
                 return( ret );
 
-            memcpy( ssl->out_iv, ssl->transform_out->iv_enc,
+            memcpy( ssl->out.iv, ssl->transform_out->iv_enc,
                     ssl->transform_out->ivlen );
 
             /*
              * Fix pointer positions and message length with added IV
              */
-            enc_msg = ssl->out_msg;
-            enc_msglen = ssl->out_msglen;
-            ssl->out_msglen += ssl->transform_out->ivlen;
+            enc_msg = ssl->out.msg;
+            enc_msglen = ssl->out.msglen;
+            ssl->out.msglen += ssl->transform_out->ivlen;
         }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
 
         MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
                             "including %d bytes of IV and %d bytes of padding",
-                            ssl->out_msglen, ssl->transform_out->ivlen,
+                            ssl->out.msglen, ssl->transform_out->ivlen,
                             padlen + 1 ) );
 
         if( ( ret = mbedtls_cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
@@ -1523,21 +1523,21 @@ static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
 
             MBEDTLS_SSL_DEBUG_MSG( 3, ( "using encrypt then mac" ) );
 
-            memcpy( pseudo_hdr +  0, ssl->out_ctr, 8 );
-            memcpy( pseudo_hdr +  8, ssl->out_hdr, 3 );
-            pseudo_hdr[11] = (unsigned char)( ( ssl->out_msglen >> 8 ) & 0xFF );
-            pseudo_hdr[12] = (unsigned char)( ( ssl->out_msglen      ) & 0xFF );
+            memcpy( pseudo_hdr +  0, ssl->out.ctr, 8 );
+            memcpy( pseudo_hdr +  8, ssl->out.hdr, 3 );
+            pseudo_hdr[11] = (unsigned char)( ( ssl->out.msglen >> 8 ) & 0xFF );
+            pseudo_hdr[12] = (unsigned char)( ( ssl->out.msglen      ) & 0xFF );
 
             MBEDTLS_SSL_DEBUG_BUF( 4, "MAC'd meta-data", pseudo_hdr, 13 );
 
             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, pseudo_hdr, 13 );
             mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc,
-                             ssl->out_iv, ssl->out_msglen );
+                             ssl->out.iv, ssl->out.msglen );
             mbedtls_md_hmac_finish( &ssl->transform_out->md_ctx_enc,
-                             ssl->out_iv + ssl->out_msglen );
+                             ssl->out.iv + ssl->out.msglen );
             mbedtls_md_hmac_reset( &ssl->transform_out->md_ctx_enc );
 
-            ssl->out_msglen += ssl->transform_out->maclen;
+            ssl->out.msglen += ssl->transform_out->maclen;
             auth_done++;
         }
 #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
@@ -1583,10 +1583,10 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
 
     mode = mbedtls_cipher_get_cipher_mode( &ssl->transform_in->cipher_ctx_dec );
 
-    if( ssl->in_msglen < ssl->transform_in->minlen )
+    if( ssl->in.msglen < ssl->transform_in->minlen )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "in_msglen (%d) < minlen (%d)",
-                       ssl->in_msglen, ssl->transform_in->minlen ) );
+                       ssl->in.msglen, ssl->transform_in->minlen ) );
         return( MBEDTLS_ERR_SSL_INVALID_MAC );
     }
 
@@ -1601,14 +1601,14 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
         if( ( ret = mbedtls_cipher_crypt( &ssl->transform_in->cipher_ctx_dec,
                                    ssl->transform_in->iv_dec,
                                    ssl->transform_in->ivlen,
-                                   ssl->in_msg, ssl->in_msglen,
-                                   ssl->in_msg, &olen ) ) != 0 )
+                                   ssl->in.msg, ssl->in.msglen,
+                                   ssl->in.msg, &olen ) ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
             return( ret );
         }
 
-        if( ssl->in_msglen != olen )
+        if( ssl->in.msglen != olen )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
@@ -1630,31 +1630,31 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
         size_t explicit_iv_len = ssl->transform_in->ivlen -
                                  ssl->transform_in->fixed_ivlen;
 
-        if( ssl->in_msglen < explicit_iv_len + taglen )
+        if( ssl->in.msglen < explicit_iv_len + taglen )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < explicit_iv_len (%d) "
-                                "+ taglen (%d)", ssl->in_msglen,
+                                "+ taglen (%d)", ssl->in.msglen,
                                 explicit_iv_len, taglen ) );
             return( MBEDTLS_ERR_SSL_INVALID_MAC );
         }
-        dec_msglen = ssl->in_msglen - explicit_iv_len - taglen;
+        dec_msglen = ssl->in.msglen - explicit_iv_len - taglen;
 
-        dec_msg = ssl->in_msg;
-        dec_msg_result = ssl->in_msg;
-        ssl->in_msglen = dec_msglen;
+        dec_msg = ssl->in.msg;
+        dec_msg_result = ssl->in.msg;
+        ssl->in.msglen = dec_msglen;
 
-        memcpy( add_data, ssl->in_ctr, 8 );
-        add_data[8]  = ssl->in_msgtype;
+        memcpy( add_data, ssl->in.ctr, 8 );
+        add_data[8]  = ssl->in.msgtype;
         mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
                            ssl->conf->transport, add_data + 9 );
-        add_data[11] = ( ssl->in_msglen >> 8 ) & 0xFF;
-        add_data[12] = ssl->in_msglen & 0xFF;
+        add_data[11] = ( ssl->in.msglen >> 8 ) & 0xFF;
+        add_data[12] = ssl->in.msglen & 0xFF;
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
                        add_data, 13 );
 
         memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,
-                ssl->in_iv,
+                ssl->in.iv,
                 ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", ssl->transform_in->iv_dec,
@@ -1711,19 +1711,19 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
             minlen += ssl->transform_in->ivlen;
 #endif
 
-        if( ssl->in_msglen < minlen + ssl->transform_in->ivlen ||
-            ssl->in_msglen < minlen + ssl->transform_in->maclen + 1 )
+        if( ssl->in.msglen < minlen + ssl->transform_in->ivlen ||
+            ssl->in.msglen < minlen + ssl->transform_in->maclen + 1 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < max( ivlen(%d), maclen (%d) "
-                                "+ 1 ) ( + expl IV )", ssl->in_msglen,
+                                "+ 1 ) ( + expl IV )", ssl->in.msglen,
                                 ssl->transform_in->ivlen,
                                 ssl->transform_in->maclen ) );
             return( MBEDTLS_ERR_SSL_INVALID_MAC );
         }
 
-        dec_msglen = ssl->in_msglen;
-        dec_msg = ssl->in_msg;
-        dec_msg_result = ssl->in_msg;
+        dec_msglen = ssl->in.msglen;
+        dec_msg = ssl->in.msg;
+        dec_msg_result = ssl->in.msg;
 
         /*
          * Authenticate before decrypt if enabled
@@ -1737,27 +1737,27 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
             MBEDTLS_SSL_DEBUG_MSG( 3, ( "using encrypt then mac" ) );
 
             dec_msglen -= ssl->transform_in->maclen;
-            ssl->in_msglen -= ssl->transform_in->maclen;
+            ssl->in.msglen -= ssl->transform_in->maclen;
 
-            memcpy( pseudo_hdr +  0, ssl->in_ctr, 8 );
-            memcpy( pseudo_hdr +  8, ssl->in_hdr, 3 );
-            pseudo_hdr[11] = (unsigned char)( ( ssl->in_msglen >> 8 ) & 0xFF );
-            pseudo_hdr[12] = (unsigned char)( ( ssl->in_msglen      ) & 0xFF );
+            memcpy( pseudo_hdr +  0, ssl->in.ctr, 8 );
+            memcpy( pseudo_hdr +  8, ssl->in.hdr, 3 );
+            pseudo_hdr[11] = (unsigned char)( ( ssl->in.msglen >> 8 ) & 0xFF );
+            pseudo_hdr[12] = (unsigned char)( ( ssl->in.msglen      ) & 0xFF );
 
             MBEDTLS_SSL_DEBUG_BUF( 4, "MAC'd meta-data", pseudo_hdr, 13 );
 
             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, pseudo_hdr, 13 );
             mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec,
-                             ssl->in_iv, ssl->in_msglen );
+                             ssl->in.iv, ssl->in.msglen );
             mbedtls_md_hmac_finish( &ssl->transform_in->md_ctx_dec, computed_mac );
             mbedtls_md_hmac_reset( &ssl->transform_in->md_ctx_dec );
 
-            MBEDTLS_SSL_DEBUG_BUF( 4, "message  mac", ssl->in_iv + ssl->in_msglen,
+            MBEDTLS_SSL_DEBUG_BUF( 4, "message  mac", ssl->in.iv + ssl->in.msglen,
                                               ssl->transform_in->maclen );
             MBEDTLS_SSL_DEBUG_BUF( 4, "computed mac", computed_mac,
                                               ssl->transform_in->maclen );
 
-            if( mbedtls_ssl_safer_memcmp( ssl->in_iv + ssl->in_msglen, computed_mac,
+            if( mbedtls_ssl_safer_memcmp( ssl->in.iv + ssl->in.msglen, computed_mac,
                               ssl->transform_in->maclen ) != 0 )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "message mac does not match" ) );
@@ -1771,10 +1771,10 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
         /*
          * Check length sanity
          */
-        if( ssl->in_msglen % ssl->transform_in->ivlen != 0 )
+        if( ssl->in.msglen % ssl->transform_in->ivlen != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) %% ivlen (%d) != 0",
-                           ssl->in_msglen, ssl->transform_in->ivlen ) );
+                           ssl->in.msglen, ssl->transform_in->ivlen ) );
             return( MBEDTLS_ERR_SSL_INVALID_MAC );
         }
 
@@ -1785,10 +1785,10 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
         {
             dec_msglen -= ssl->transform_in->ivlen;
-            ssl->in_msglen -= ssl->transform_in->ivlen;
+            ssl->in.msglen -= ssl->transform_in->ivlen;
 
             for( i = 0; i < ssl->transform_in->ivlen; i++ )
-                ssl->transform_in->iv_dec[i] = ssl->in_iv[i];
+                ssl->transform_in->iv_dec[i] = ssl->in.iv[i];
         }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
 
@@ -1820,14 +1820,14 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
         }
 #endif
 
-        padlen = 1 + ssl->in_msg[ssl->in_msglen - 1];
+        padlen = 1 + ssl->in.msg[ssl->in.msglen - 1];
 
-        if( ssl->in_msglen < ssl->transform_in->maclen + padlen &&
+        if( ssl->in.msglen < ssl->transform_in->maclen + padlen &&
             auth_done == 0 )
         {
 #if defined(MBEDTLS_SSL_DEBUG_ALL)
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < maclen (%d) + padlen (%d)",
-                        ssl->in_msglen, ssl->transform_in->maclen, padlen ) );
+                        ssl->in.msglen, ssl->transform_in->maclen, padlen ) );
 #endif
             padlen = 0;
             correct = 0;
@@ -1857,11 +1857,11 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
              * and fake check up to 256 bytes of padding
              */
             size_t pad_count = 0, real_count = 1;
-            size_t padding_idx = ssl->in_msglen - padlen - 1;
+            size_t padding_idx = ssl->in.msglen - padlen - 1;
 
             /*
              * Padding is guaranteed to be incorrect if:
-             *   1. padlen >= ssl->in_msglen
+             *   1. padlen >= ssl->in.msglen
              *
              *   2. padding_idx >= MBEDTLS_SSL_MAX_CONTENT_LEN +
              *                     ssl->transform_in->maclen
@@ -1869,7 +1869,7 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
              * In both cases we reset padding_idx to a safe value (0) to
              * prevent out-of-buffer reads.
              */
-            correct &= ( ssl->in_msglen >= padlen + 1 );
+            correct &= ( ssl->in.msglen >= padlen + 1 );
             correct &= ( padding_idx < MBEDTLS_SSL_MAX_CONTENT_LEN +
                                        ssl->transform_in->maclen );
 
@@ -1879,7 +1879,7 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
             {
                 real_count &= ( i <= padlen );
                 pad_count += real_count *
-                             ( ssl->in_msg[padding_idx + i] == padlen - 1 );
+                             ( ssl->in.msg[padding_idx + i] == padlen - 1 );
             }
 
             correct &= ( pad_count == padlen ); /* Only 1 on correct padding */
@@ -1898,7 +1898,7 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
         }
 
-        ssl->in_msglen -= padlen;
+        ssl->in.msglen -= padlen;
     }
     else
 #endif /* MBEDTLS_CIPHER_MODE_CBC &&
@@ -1909,7 +1909,7 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
     }
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "raw buffer after decryption",
-                   ssl->in_msg, ssl->in_msglen );
+                   ssl->in.msg, ssl->in.msglen );
 
     /*
      * Authenticate if not done yet.
@@ -1920,20 +1920,20 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
     {
         unsigned char tmp[SSL_MAX_MAC_SIZE];
 
-        ssl->in_msglen -= ssl->transform_in->maclen;
+        ssl->in.msglen -= ssl->transform_in->maclen;
 
-        ssl->in_len[0] = (unsigned char)( ssl->in_msglen >> 8 );
-        ssl->in_len[1] = (unsigned char)( ssl->in_msglen      );
+        ssl->in.len[0] = (unsigned char)( ssl->in.msglen >> 8 );
+        ssl->in.len[1] = (unsigned char)( ssl->in.msglen      );
 
-        memcpy( tmp, ssl->in_msg + ssl->in_msglen, ssl->transform_in->maclen );
+        memcpy( tmp, ssl->in.msg + ssl->in.msglen, ssl->transform_in->maclen );
 
 #if defined(MBEDTLS_SSL_PROTO_SSL3)
         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
         {
             ssl_mac( &ssl->transform_in->md_ctx_dec,
                       ssl->transform_in->mac_dec,
-                      ssl->in_msg, ssl->in_msglen,
-                      ssl->in_ctr, ssl->in_msgtype );
+                      ssl->in.msg, ssl->in.msglen,
+                      ssl->in.ctr, ssl->in.msgtype );
         }
         else
 #endif /* MBEDTLS_SSL_PROTO_SSL3 */
@@ -1955,21 +1955,21 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
              * value for our calculations instead of -55)
              */
             size_t j, extra_run = 0;
-            extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64 -
-                        ( 13 + ssl->in_msglen          + 8 ) / 64;
+            extra_run = ( 13 + ssl->in.msglen + padlen + 8 ) / 64 -
+                        ( 13 + ssl->in.msglen          + 8 ) / 64;
 
             extra_run &= correct * 0xFF;
 
-            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_ctr, 8 );
-            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_hdr, 3 );
-            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_len, 2 );
-            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_msg,
-                             ssl->in_msglen );
+            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in.ctr, 8 );
+            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in.hdr, 3 );
+            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in.len, 2 );
+            mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in.msg,
+                             ssl->in.msglen );
             mbedtls_md_hmac_finish( &ssl->transform_in->md_ctx_dec,
-                             ssl->in_msg + ssl->in_msglen );
+                             ssl->in.msg + ssl->in.msglen );
             /* Call mbedtls_md_process at least once due to cache attacks */
             for( j = 0; j < extra_run + 1; j++ )
-                mbedtls_md_process( &ssl->transform_in->md_ctx_dec, ssl->in_msg );
+                mbedtls_md_process( &ssl->transform_in->md_ctx_dec, ssl->in.msg);
 
             mbedtls_md_hmac_reset( &ssl->transform_in->md_ctx_dec );
         }
@@ -1982,10 +1982,10 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
         }
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "message  mac", tmp, ssl->transform_in->maclen );
-        MBEDTLS_SSL_DEBUG_BUF( 4, "computed mac", ssl->in_msg + ssl->in_msglen,
+        MBEDTLS_SSL_DEBUG_BUF( 4, "computed mac", ssl->in.msg + ssl->in.msglen,
                        ssl->transform_in->maclen );
 
-        if( mbedtls_ssl_safer_memcmp( tmp, ssl->in_msg + ssl->in_msglen,
+        if( mbedtls_ssl_safer_memcmp( tmp, ssl->in.msg + ssl->in.msglen,
                          ssl->transform_in->maclen ) != 0 )
         {
 #if defined(MBEDTLS_SSL_DEBUG_ALL)
@@ -2010,7 +2010,7 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
     }
 
-    if( ssl->in_msglen == 0 )
+    if( ssl->in.msglen == 0 )
     {
         ssl->nb_zero++;
 
@@ -2037,7 +2037,7 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
 #endif
     {
         for( i = 8; i > ssl_ep_len( ssl ); i-- )
-            if( ++ssl->in_ctr[i - 1] != 0 )
+            if( ++ssl->in.ctr[i - 1] != 0 )
                 break;
 
         /* The loop goes to its end iff the counter is wrapping */
@@ -2064,8 +2064,8 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
 static int ssl_compress_buf( mbedtls_ssl_context *ssl )
 {
     int ret;
-    unsigned char *msg_post = ssl->out_msg;
-    size_t len_pre = ssl->out_msglen;
+    unsigned char *msg_post = ssl->out.msg;
+    size_t len_pre = ssl->out.msglen;
     unsigned char *msg_pre = ssl->compress_buf;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> compress buf" ) );
@@ -2073,13 +2073,13 @@ static int ssl_compress_buf( mbedtls_ssl_context *ssl )
     if( len_pre == 0 )
         return( 0 );
 
-    memcpy( msg_pre, ssl->out_msg, len_pre );
+    memcpy( msg_pre, ssl->out.msg, len_pre );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "before compression: msglen = %d, ",
-                   ssl->out_msglen ) );
+                   ssl->out.msglen ) );
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "before compression: output payload",
-                   ssl->out_msg, ssl->out_msglen );
+                   ssl->out.msg, ssl->out.msglen );
 
     ssl->transform_out->ctx_deflate.next_in = msg_pre;
     ssl->transform_out->ctx_deflate.avail_in = len_pre;
@@ -2093,14 +2093,14 @@ static int ssl_compress_buf( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
     }
 
-    ssl->out_msglen = MBEDTLS_SSL_BUFFER_LEN -
+    ssl->out.msglen = MBEDTLS_SSL_BUFFER_LEN -
                       ssl->transform_out->ctx_deflate.avail_out;
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "after compression: msglen = %d, ",
-                   ssl->out_msglen ) );
+                   ssl->out.msglen ) );
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "after compression: output payload",
-                   ssl->out_msg, ssl->out_msglen );
+                   ssl->out.msg, ssl->out.msglen );
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= compress buf" ) );
 
@@ -2110,8 +2110,8 @@ static int ssl_compress_buf( mbedtls_ssl_context *ssl )
 static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
 {
     int ret;
-    unsigned char *msg_post = ssl->in_msg;
-    size_t len_pre = ssl->in_msglen;
+    unsigned char *msg_post = ssl->in.msg;
+    size_t len_pre = ssl->in.msglen;
     unsigned char *msg_pre = ssl->compress_buf;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> decompress buf" ) );
@@ -2119,13 +2119,13 @@ static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
     if( len_pre == 0 )
         return( 0 );
 
-    memcpy( msg_pre, ssl->in_msg, len_pre );
+    memcpy( msg_pre, ssl->in.msg len_pre );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "before decompression: msglen = %d, ",
-                   ssl->in_msglen ) );
+                   ssl->in.msglen ) );
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "before decompression: input payload",
-                   ssl->in_msg, ssl->in_msglen );
+                   ssl->in.msg, ssl->in.msglen );
 
     ssl->transform_in->ctx_inflate.next_in = msg_pre;
     ssl->transform_in->ctx_inflate.avail_in = len_pre;
@@ -2139,14 +2139,14 @@ static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
     }
 
-    ssl->in_msglen = MBEDTLS_SSL_MAX_CONTENT_LEN -
+    ssl->in.msglen = MBEDTLS_SSL_MAX_CONTENT_LEN -
                      ssl->transform_in->ctx_inflate.avail_out;
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "after decompression: msglen = %d, ",
-                   ssl->in_msglen ) );
+                   ssl->in.msglen ) );
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "after decompression: input payload",
-                   ssl->in_msg, ssl->in_msglen );
+                   ssl->in.msg, ssl->in.msglen );
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= decompress buf" ) );
 
@@ -2187,14 +2187,14 @@ static int ssl_resend_hello_request( mbedtls_ssl_context *ssl )
 
 /*
  * Fill the input message buffer by appending data to it.
- * The amount of data already fetched is in ssl->in_left.
+ * The amount of data already fetched is in ssl->in.left.
  *
  * If we return 0, is it guaranteed that (at least) nb_want bytes are
  * available (from this read and/or a previous one). Otherwise, an error code
  * is returned (possibly EOF or WANT_READ).
  *
- * With stream transport (TLS) on success ssl->in_left == nb_want, but
- * with datagram transport (DTLS) on success ssl->in_left >= nb_want,
+ * With stream transport (TLS) on success ssl->in.left == nb_want, but
+ * with datagram transport (DTLS) on success ssl->in.left >= nb_want,
  * since we always read a whole datagram at once.
  *
  * For DTLS, it is up to the caller to set ssl->next_record_offset when
@@ -2214,7 +2214,7 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
     }
 
-    if( nb_want > MBEDTLS_SSL_BUFFER_LEN - (size_t)( ssl->in_hdr - ssl->in_buf ) )
+    if( nb_want > MBEDTLS_SSL_BUFFER_LEN - (size_t)( ssl->in.hdr - ssl->in.buf ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "requesting more data than fits" ) );
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
@@ -2245,33 +2245,32 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
          */
         if( ssl->next_record_offset != 0 )
         {
-            if( ssl->in_left < ssl->next_record_offset )
+            if( ssl->in.left < ssl->next_record_offset )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
                 return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
             }
+            ssl->in.left -= ssl->next_record_offset;
 
-            ssl->in_left -= ssl->next_record_offset;
-
-            if( ssl->in_left != 0 )
+            if( ssl->in.left != 0 )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "next record in same datagram, offset: %d",
                                     ssl->next_record_offset ) );
-                memmove( ssl->in_hdr,
-                         ssl->in_hdr + ssl->next_record_offset,
-                         ssl->in_left );
+                memmove( ssl->in.hdr,
+                         ssl->in.hdr + ssl->next_record_offset,
+                         ssl->in.left );
             }
 
             ssl->next_record_offset = 0;
         }
 
         MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
-                       ssl->in_left, nb_want ) );
+                       ssl->in.left, nb_want ) );
 
         /*
          * Done if we already have enough data.
          */
-        if( nb_want <= ssl->in_left)
+        if( nb_want <= ssl->in.left)
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= fetch input" ) );
             return( 0 );
@@ -2282,7 +2281,7 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
          * are not at the beginning of a new record, the caller did something
          * wrong.
          */
-        if( ssl->in_left != 0 )
+        if( ssl->in.left != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
@@ -2297,7 +2296,7 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
             ret = MBEDTLS_ERR_SSL_TIMEOUT;
         else
         {
-            len = MBEDTLS_SSL_BUFFER_LEN - ( ssl->in_hdr - ssl->in_buf );
+            len = MBEDTLS_SSL_BUFFER_LEN - ( ssl->in.hdr - ssl->in.buf );
 
             if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
                 timeout = ssl->handshake->retransmit_timeout;
@@ -2307,10 +2306,10 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
             MBEDTLS_SSL_DEBUG_MSG( 3, ( "f_recv_timeout: %u ms", timeout ) );
 
             if( ssl->f_recv_timeout != NULL )
-                ret = ssl->f_recv_timeout( ssl->p_bio, ssl->in_hdr, len,
+                ret = ssl->f_recv_timeout( ssl->p_bio, ssl->in.hdr, len,
                                                                     timeout );
             else
-                ret = ssl->f_recv( ssl->p_bio, ssl->in_hdr, len );
+                ret = ssl->f_recv( ssl->p_bio, ssl->in.hdr, len );
 
             MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_recv(_timeout)", ret );
 
@@ -2357,17 +2356,17 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
         if( ret < 0 )
             return( ret );
 
-        ssl->in_left = ret;
+        ssl->in.left = ret;
     }
     else
 #endif
     {
         MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
-                       ssl->in_left, nb_want ) );
+                       ssl->in.left, nb_want ) );
 
-        while( ssl->in_left < nb_want )
+        while( ssl->in.left < nb_want )
         {
-            len = nb_want - ssl->in_left;
+            len = nb_want - ssl->in.left;
 
             if( ssl_check_timer( ssl ) != 0 )
                 ret = MBEDTLS_ERR_SSL_TIMEOUT;
@@ -2376,18 +2375,18 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
                 if( ssl->f_recv_timeout != NULL )
                 {
                     ret = ssl->f_recv_timeout( ssl->p_bio,
-                                               ssl->in_hdr + ssl->in_left, len,
+                                               ssl->in.hdr + ssl->in.left, len,
                                                ssl->conf->read_timeout );
                 }
                 else
                 {
                     ret = ssl->f_recv( ssl->p_bio,
-                                       ssl->in_hdr + ssl->in_left, len );
+                                       ssl->in.hdr + ssl->in.left, len );
                 }
             }
 
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
-                                        ssl->in_left, nb_want ) );
+                                        ssl->in.left, nb_want ) );
             MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_recv(_timeout)", ret );
 
             if( ret == 0 )
@@ -2396,7 +2395,7 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
             if( ret < 0 )
                 return( ret );
 
-            ssl->in_left += ret;
+            ssl->in.left += ret;
         }
     }
 
@@ -2423,31 +2422,31 @@ int mbedtls_ssl_flush_output( mbedtls_ssl_context *ssl )
     }
 
     /* Avoid incrementing counter if data is flushed */
-    if( ssl->out_left == 0 )
+    if( ssl->out.left == 0 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= flush output" ) );
         return( 0 );
     }
 
-    while( ssl->out_left > 0 )
+    while( ssl->out.left > 0 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 2, ( "message length: %d, out_left: %d",
-                       mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen, ssl->out_left ) );
+                       mbedtls_ssl_hdr_len( ssl ) + ssl->out.msglen, ssl->out.left ) );
 
-        buf = ssl->out_hdr + mbedtls_ssl_hdr_len( ssl ) +
-              ssl->out_msglen - ssl->out_left;
-        ret = ssl->f_send( ssl->p_bio, buf, ssl->out_left );
+        buf = ssl->out.hdr + mbedtls_ssl_hdr_len( ssl ) +
+              ssl->out.msglen - ssl->out.left;
+        ret = ssl->f_send( ssl->p_bio, buf, ssl->out.left );
 
         MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_send", ret );
 
         if( ret <= 0 )
             return( ret );
 
-        ssl->out_left -= ret;
+        ssl->out.left -= ret;
     }
 
     for( i = 8; i > ssl_ep_len( ssl ); i-- )
-        if( ++ssl->out_ctr[i - 1] != 0 )
+        if( ++ssl->out.ctr[i - 1] != 0 )
             break;
 
     /* The loop goes to its end iff the counter is wrapping */
@@ -2481,17 +2480,17 @@ static int ssl_flight_append( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
     }
 
-    if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )
+    if( ( msg->p = mbedtls_calloc( 1, ssl->out.msglen ) ) == NULL )
     {
-        MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc %d bytes failed", ssl->out_msglen ) );
+        MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc %d bytes failed", ssl->out.msglen ) );
         mbedtls_free( msg );
         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
     }
 
     /* Copy current handshake message with headers */
-    memcpy( msg->p, ssl->out_msg, ssl->out_msglen );
-    msg->len = ssl->out_msglen;
-    msg->type = ssl->out_msgtype;
+    memcpy( msg->p, ssl->out.msg, ssl->out.msglen );
+    msg->len = ssl->out.msglen;
+    msg->type = ssl->out.msgtype;
     msg->next = NULL;
 
     /* Append to the current flight */
@@ -2553,19 +2552,19 @@ static void ssl_swap_epochs( mbedtls_ssl_context *ssl )
     ssl->handshake->alt_transform_out = tmp_transform;
 
     /* Swap epoch + sequence_number */
-    memcpy( tmp_out_ctr,                 ssl->out_ctr,                8 );
-    memcpy( ssl->out_ctr,                ssl->handshake->alt_out_ctr, 8 );
+    memcpy( tmp_out_ctr,                 ssl->out.ctr,                8 );
+    memcpy( ssl->out.ctr,                ssl->handshake->alt_out_ctr, 8 );
     memcpy( ssl->handshake->alt_out_ctr, tmp_out_ctr,                 8 );
 
     /* Adjust to the newly activated transform */
     if( ssl->transform_out != NULL &&
         ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
     {
-        ssl->out_msg = ssl->out_iv + ssl->transform_out->ivlen -
+        ssl->out.msg = ssl->out.iv + ssl->transform_out->ivlen -
                                      ssl->transform_out->fixed_ivlen;
     }
     else
-        ssl->out_msg = ssl->out_iv;
+        ssl->out.msg = ssl->out.iv;
 
 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
     if( mbedtls_ssl_hw_record_activate != NULL )
@@ -2614,13 +2613,13 @@ int mbedtls_ssl_resend( mbedtls_ssl_context *ssl )
             ssl_swap_epochs( ssl );
         }
 
-        memcpy( ssl->out_msg, cur->p, cur->len );
-        ssl->out_msglen = cur->len;
-        ssl->out_msgtype = cur->type;
+        memcpy( ssl->out.msg, cur->p, cur->len );
+        ssl->out.msglen = cur->len;
+        ssl->out.msgtype = cur->type;
 
         ssl->handshake->cur_msg = cur->next;
 
-        MBEDTLS_SSL_DEBUG_BUF( 3, "resent handshake message header", ssl->out_msg, 12 );
+        MBEDTLS_SSL_DEBUG_BUF( 3, "resent handshake message header", ssl->out.msg, 12 );
 
         if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
         {
@@ -2658,8 +2657,8 @@ void mbedtls_ssl_recv_flight_completed( mbedtls_ssl_context *ssl )
     /* Cancel timer */
     ssl_set_timer( ssl, 0 );
 
-    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
-        ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
+    if( ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
+        ssl->in.msg[0] == MBEDTLS_SSL_HS_FINISHED )
     {
         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
     }
@@ -2675,8 +2674,8 @@ void mbedtls_ssl_send_flight_completed( mbedtls_ssl_context *ssl )
     ssl_reset_retransmit_timeout( ssl );
     ssl_set_timer( ssl, ssl->handshake->retransmit_timeout );
 
-    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
-        ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
+    if( ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
+        ssl->in.msg[0] == MBEDTLS_SSL_HS_FINISHED )
     {
         ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
     }
@@ -2691,12 +2690,12 @@ void mbedtls_ssl_send_flight_completed( mbedtls_ssl_context *ssl )
 
 /*
  * Write current record.
- * Uses ssl->out_msgtype, ssl->out_msglen and bytes at ssl->out_msg.
+ * Uses ssl->out.msgtype, ssl->out.msglen and bytes at ssl->out.msg.
  */
 int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
 {
     int ret, done = 0, out_msg_type;
-    size_t len = ssl->out_msglen;
+    size_t len = ssl->out.msglen;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write record" ) );
 
@@ -2709,9 +2708,9 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
     }
     else
 #endif
-    if( ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->out.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
     {
-        out_msg_type = ssl->out_msg[0];
+        out_msg_type = ssl->out.msg[0];
 
         if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST &&
             ssl->handshake == NULL )
@@ -2720,9 +2719,9 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
         }
 
-        ssl->out_msg[1] = (unsigned char)( ( len - 4 ) >> 16 );
-        ssl->out_msg[2] = (unsigned char)( ( len - 4 ) >>  8 );
-        ssl->out_msg[3] = (unsigned char)( ( len - 4 )       );
+        ssl->out.msg[1] = (unsigned char)( ( len - 4 ) >> 16 );
+        ssl->out.msg[2] = (unsigned char)( ( len - 4 ) >>  8 );
+        ssl->out.msg[3] = (unsigned char)( ( len - 4 )       );
 
         /*
          * DTLS has additional fields in the Handshake layer,
@@ -2735,31 +2734,31 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
         if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
         {
             /* Make room for the additional DTLS fields */
-            memmove( ssl->out_msg + 12, ssl->out_msg + 4, len - 4 );
-            ssl->out_msglen += 8;
+            memmove( ssl->out.msg + 12, ssl->out.msg + 4, len - 4 );
+            ssl->out.msglen += 8;
             len += 8;
 
             /* Write message_seq and update it, except for HelloRequest */
             if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST )
             {
-                ssl->out_msg[4] = ( ssl->handshake->out_msg_seq >> 8 ) & 0xFF;
-                ssl->out_msg[5] = ( ssl->handshake->out_msg_seq      ) & 0xFF;
+                ssl->out.msg[4] = ( ssl->handshake->out_msg_seq >> 8 ) & 0xFF;
+                ssl->out.msg[5] = ( ssl->handshake->out_msg_seq      ) & 0xFF;
                 ++( ssl->handshake->out_msg_seq );
             }
             else
             {
-                ssl->out_msg[4] = 0;
-                ssl->out_msg[5] = 0;
+                ssl->out.msg[4] = 0;
+                ssl->out.msg[5] = 0;
             }
 
             /* We don't fragment, so frag_offset = 0 and frag_len = len */
-            memset( ssl->out_msg + 6, 0x00, 3 );
-            memcpy( ssl->out_msg + 9, ssl->out_msg + 1, 3 );
+            memset( ssl->out.msg + 6, 0x00, 3 );
+            memcpy( ssl->out.msg + 9, ssl->out.msg + 1, 3 );
         }
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
 
         if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST )
-            ssl->handshake->update_checksum( ssl, ssl->out_msg, len );
+            ssl->handshake->update_checksum( ssl, ssl->out.msg, len );
     }
 
     /* Save handshake and CCS messages for resending */
@@ -2767,8 +2766,8 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
         ssl->handshake != NULL &&
         ssl->handshake->retransmit_state != MBEDTLS_SSL_RETRANS_SENDING &&
-        ( ssl->out_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC ||
-          ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE ) )
+        ( ssl->out.msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC ||
+          ssl->out.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE ) )
     {
         if( ( ret = ssl_flight_append( ssl ) ) != 0 )
         {
@@ -2788,7 +2787,7 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
             return( ret );
         }
 
-        len = ssl->out_msglen;
+        len = ssl->out.msglen;
     }
 #endif /*MBEDTLS_ZLIB_SUPPORT */
 
@@ -2810,12 +2809,12 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
 #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
     if( !done )
     {
-        ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;
+        ssl->out.hdr[0] = (unsigned char) ssl->out.msgtype;
         mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
-                           ssl->conf->transport, ssl->out_hdr + 1 );
+                           ssl->conf->transport, ssl->out.hdr + 1 );
 
-        ssl->out_len[0] = (unsigned char)( len >> 8 );
-        ssl->out_len[1] = (unsigned char)( len      );
+        ssl->out.len[0] = (unsigned char)( len >> 8 );
+        ssl->out.len[1] = (unsigned char)( len      );
 
         if( ssl->transform_out != NULL )
         {
@@ -2825,20 +2824,20 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
                 return( ret );
             }
 
-            len = ssl->out_msglen;
-            ssl->out_len[0] = (unsigned char)( len >> 8 );
-            ssl->out_len[1] = (unsigned char)( len      );
+            len = ssl->out.msglen;
+            ssl->out.len[0] = (unsigned char)( len >> 8 );
+            ssl->out.len[1] = (unsigned char)( len      );
         }
 
-        ssl->out_left = mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen;
+        ssl->out.left = mbedtls_ssl_hdr_len( ssl ) + ssl->out.msglen;
 
         MBEDTLS_SSL_DEBUG_MSG( 3, ( "output record: msgtype = %d, "
                             "version = [%d:%d], msglen = %d",
-                       ssl->out_hdr[0], ssl->out_hdr[1], ssl->out_hdr[2],
-                     ( ssl->out_len[0] << 8 ) | ssl->out_len[1] ) );
+                       ssl->out.hdr[0], ssl->out.hdr[1], ssl->out.hdr[2],
+                     ( ssl->out.len[0] << 8 ) | ssl->out.len[1] ) );
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "output record sent to network",
-                       ssl->out_hdr, mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen );
+                       ssl->out.hdr, mbedtls_ssl_hdr_len( ssl ) + ssl->out.msglen );
     }
 
     if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
@@ -2962,7 +2961,7 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
 
         /* Prepare final header: copy msg_type, length and message_seq,
          * then add standardised fragment_offset and fragment_length */
-        memcpy( ssl->handshake->hs_msg, ssl->in_msg, 6 );
+        memcpy( ssl->handshake->hs_msg, ssl->in.msg, 6 );
         memset( ssl->handshake->hs_msg + 6, 0, 3 );
         memcpy( ssl->handshake->hs_msg + 9,
                 ssl->handshake->hs_msg + 1, 3 );
@@ -2970,7 +2969,7 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
     else
     {
         /* Make sure msg_type and length are consistent */
-        if( memcmp( ssl->handshake->hs_msg, ssl->in_msg, 4 ) != 0 )
+        if( memcmp( ssl->handshake->hs_msg, ssl->in.msg, 4 ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "fragment header mismatch" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -2983,12 +2982,12 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
     /*
      * Check and copy current fragment
      */
-    frag_off = ( ssl->in_msg[6]  << 16 ) |
-               ( ssl->in_msg[7]  << 8  ) |
-                 ssl->in_msg[8];
-    frag_len = ( ssl->in_msg[9]  << 16 ) |
-               ( ssl->in_msg[10] << 8  ) |
-                 ssl->in_msg[11];
+    frag_off = ( ssl->in.msg[6]  << 16 ) |
+               ( ssl->in.msg[7]  << 8  ) |
+                 ssl->in.msg[8];
+    frag_len = ( ssl->in.msg[9]  << 16 ) |
+               ( ssl->in.msg[10] << 8  ) |
+                 ssl->in.msg[11];
 
     if( frag_off + frag_len > msg_len )
     {
@@ -2997,17 +2996,17 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
     }
 
-    if( frag_len + 12 > ssl->in_msglen )
+    if( frag_len + 12 > ssl->in.msglen )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid fragment length: %d + 12 > %d",
-                          frag_len, ssl->in_msglen ) );
+                          frag_len, ssl->in.msglen ) );
         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
     }
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "adding fragment, offset = %d, length = %d",
                         frag_off, frag_len ) );
 
-    memcpy( msg + frag_off, ssl->in_msg + 12, frag_len );
+    memcpy( msg + frag_off, ssl->in.msg + 12, frag_len );
     ssl_bitmask_set( bitmask, frag_off, frag_len );
 
     /*
@@ -3022,7 +3021,7 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "handshake message completed" ) );
 
-    if( frag_len + 12 < ssl->in_msglen )
+    if( frag_len + 12 < ssl->in.msglen )
     {
         /*
          * We'got more handshake messages in the same record.
@@ -3033,23 +3032,23 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
     }
 
-    if( ssl->in_left > ssl->next_record_offset )
+    if( ssl->in.left > ssl->next_record_offset )
     {
         /*
          * We've got more data in the buffer after the current record,
          * that we don't want to overwrite. Move it before writing the
          * reassembled message, and adjust in_left and next_record_offset.
          */
-        unsigned char *cur_remain = ssl->in_hdr + ssl->next_record_offset;
-        unsigned char *new_remain = ssl->in_msg + ssl->in_hslen;
-        size_t remain_len = ssl->in_left - ssl->next_record_offset;
+        unsigned char *cur_remain = ssl->in.hdr + ssl->next_record_offset;
+        unsigned char *new_remain = ssl->in.msg + ssl->in_hslen;
+        size_t remain_len = ssl->in.left - ssl->next_record_offset;
 
         /* First compute and check new lengths */
-        ssl->next_record_offset = new_remain - ssl->in_hdr;
-        ssl->in_left = ssl->next_record_offset + remain_len;
+        ssl->next_record_offset = new_remain - ssl->in.hdr;
+        ssl->in.left = ssl->next_record_offset + remain_len;
 
-        if( ssl->in_left > MBEDTLS_SSL_BUFFER_LEN -
-                           (size_t)( ssl->in_hdr - ssl->in_buf ) )
+        if( ssl->in.left > MBEDTLS_SSL_BUFFER_LEN -
+                           (size_t)( ssl->in.hdr - ssl->in.buf ) )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "reassembled message too large for buffer" ) );
             return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
@@ -3058,13 +3057,13 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
         memmove( new_remain, cur_remain, remain_len );
     }
 
-    memcpy( ssl->in_msg, ssl->handshake->hs_msg, ssl->in_hslen );
+    memcpy( ssl->in.msg, ssl->handshake->hs_msg, ssl->in_hslen );
 
     mbedtls_free( ssl->handshake->hs_msg );
     ssl->handshake->hs_msg = NULL;
 
     MBEDTLS_SSL_DEBUG_BUF( 3, "reassembled handshake message",
-                   ssl->in_msg, ssl->in_hslen );
+                   ssl->in.msg, ssl->in_hslen );
 
     return( 0 );
 }
@@ -3072,27 +3071,27 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
 
 int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
 {
-    if( ssl->in_msglen < mbedtls_ssl_hs_hdr_len( ssl ) )
+    if( ssl->in.msglen < mbedtls_ssl_hs_hdr_len( ssl ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake message too short: %d",
-                            ssl->in_msglen ) );
+                            ssl->in.msglen ) );
         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
     }
 
     ssl->in_hslen = mbedtls_ssl_hs_hdr_len( ssl ) + (
-                    ( ssl->in_msg[1] << 16 ) |
-                    ( ssl->in_msg[2] << 8  ) |
-                      ssl->in_msg[3] );
+                    ( ssl->in.msg[1] << 16 ) |
+                    ( ssl->in.msg[2] << 8  ) |
+                      ssl->in.msg[3] );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "handshake message: msglen ="
                         " %d, type = %d, hslen = %d",
-                        ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen ) );
+                        ssl->in.msglen, ssl->in.msg[0], ssl->in_hslen ) );
 
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
     {
         int ret;
-        unsigned int recv_msg_seq = ( ssl->in_msg[4] << 8 ) | ssl->in_msg[5];
+        unsigned int recv_msg_seq = ( ssl->in.msg[4] << 8 ) | ssl->in.msg[5];
 
         /* ssl->handshake is NULL when receiving ClientHello for renego */
         if( ssl->handshake != NULL &&
@@ -3102,7 +3101,7 @@ int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
              * too many retransmissions.
              * Besides, No sane server ever retransmits HelloVerifyRequest */
             if( recv_msg_seq == ssl->handshake->in_flight_start_seq - 1 &&
-                ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST )
+                ssl->in.msg[0] != MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "received message from last flight, "
                                     "message_seq = %d, start_of_flight = %d",
@@ -3129,9 +3128,9 @@ int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
 
         /* Reassemble if current message is fragmented or reassembly is
          * already in progress */
-        if( ssl->in_msglen < ssl->in_hslen ||
-            memcmp( ssl->in_msg + 6, "\0\0\0",        3 ) != 0 ||
-            memcmp( ssl->in_msg + 9, ssl->in_msg + 1, 3 ) != 0 ||
+        if( ssl->in.msglen < ssl->in_hslen ||
+            memcmp( ssl->in.msg + 6, "\0\0\0",        3 ) != 0 ||
+            memcmp( ssl->in.msg + 9, ssl->in.msg + 1, 3 ) != 0 ||
             ( ssl->handshake != NULL && ssl->handshake->hs_msg != NULL ) )
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "found fragmented DTLS handshake message" ) );
@@ -3146,7 +3145,7 @@ int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
     else
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
     /* With TLS we don't handle fragmentation (for now) */
-    if( ssl->in_msglen < ssl->in_hslen )
+    if( ssl->in.msglen < ssl->in_hslen )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLS handshake fragmentation not supported" ) );
         return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
@@ -3161,7 +3160,7 @@ void mbedtls_ssl_update_handshake_status( mbedtls_ssl_context *ssl )
     if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER &&
         ssl->handshake != NULL )
     {
-        ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );
+        ssl->handshake->update_checksum( ssl, ssl->in.msg, ssl->in_hslen );
     }
 
     /* Handshake message is complete, increment counter */
@@ -3206,7 +3205,7 @@ static inline uint64_t ssl_load_six_bytes( unsigned char *buf )
  */
 int mbedtls_ssl_dtls_replay_check( mbedtls_ssl_context *ssl )
 {
-    uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in_ctr + 2 );
+    uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in.ctr + 2 );
     uint64_t bit;
 
     if( ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED )
@@ -3231,7 +3230,7 @@ int mbedtls_ssl_dtls_replay_check( mbedtls_ssl_context *ssl )
  */
 void mbedtls_ssl_dtls_replay_update( mbedtls_ssl_context *ssl )
 {
-    uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in_ctr + 2 );
+    uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in.ctr + 2 );
 
     if( ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED )
         return;
@@ -3421,8 +3420,8 @@ static int ssl_handle_possible_reconnect( mbedtls_ssl_context *ssl )
             ssl->conf->f_cookie_check,
             ssl->conf->p_cookie,
             ssl->cli_id, ssl->cli_id_len,
-            ssl->in_buf, ssl->in_left,
-            ssl->out_buf, MBEDTLS_SSL_MAX_CONTENT_LEN, &len );
+            ssl->in.buf, ssl->in.left,
+            ssl->out.buf, MBEDTLS_SSL_MAX_CONTENT_LEN, &len );
 
     MBEDTLS_SSL_DEBUG_RET( 2, "ssl_check_dtls_clihlo_cookie", ret );
 
@@ -3431,7 +3430,7 @@ static int ssl_handle_possible_reconnect( mbedtls_ssl_context *ssl )
         /* Don't check write errors as we can't do anything here.
          * If the error is permanent we'll catch it later,
          * if it's not, then hopefully it'll work next time. */
-        (void) ssl->f_send( ssl->p_bio, ssl->out_buf, len );
+        (void) ssl->f_send( ssl->p_bio, ssl->out.buf, len );
 
         return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
     }
@@ -3475,22 +3474,22 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
 {
     int major_ver, minor_ver;
 
-    MBEDTLS_SSL_DEBUG_BUF( 4, "input record header", ssl->in_hdr, mbedtls_ssl_hdr_len( ssl ) );
+    MBEDTLS_SSL_DEBUG_BUF( 4, "input record header", ssl->in.hdr, mbedtls_ssl_hdr_len( ssl ) );
 
-    ssl->in_msgtype =  ssl->in_hdr[0];
-    ssl->in_msglen = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
-    mbedtls_ssl_read_version( &major_ver, &minor_ver, ssl->conf->transport, ssl->in_hdr + 1 );
+    ssl->in.msgtype =  ssl->in.hdr[0];
+    ssl->in.msglen = ( ssl->in.len[0] << 8 ) | ssl->in.len[1];
+    mbedtls_ssl_read_version( &major_ver, &minor_ver, ssl->conf->transport, ssl->in.hdr + 1 );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "input record: msgtype = %d, "
                         "version = [%d:%d], msglen = %d",
-                        ssl->in_msgtype,
-                        major_ver, minor_ver, ssl->in_msglen ) );
+                        ssl->in.msgtype,
+                        major_ver, minor_ver, ssl->in.msglen ) );
 
     /* Check record type */
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE &&
-        ssl->in_msgtype != MBEDTLS_SSL_MSG_ALERT &&
-        ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
-        ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE &&
+        ssl->in.msgtype != MBEDTLS_SSL_MSG_ALERT &&
+        ssl->in.msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
+        ssl->in.msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "unknown record type" ) );
 
@@ -3519,8 +3518,8 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
     }
 
     /* Check length against the size of our buffer */
-    if( ssl->in_msglen > MBEDTLS_SSL_BUFFER_LEN
-                         - (size_t)( ssl->in_msg - ssl->in_buf ) )
+    if( ssl->in.msglen > MBEDTLS_SSL_BUFFER_LEN
+                         - (size_t)( ssl->in.msg- ssl->in.buf ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3529,8 +3528,8 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
     /* Check length against bounds of the current transform and version */
     if( ssl->transform_in == NULL )
     {
-        if( ssl->in_msglen < 1 ||
-            ssl->in_msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
+        if( ssl->in.msglen < 1 ||
+            ssl->in.msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3538,7 +3537,7 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
     }
     else
     {
-        if( ssl->in_msglen < ssl->transform_in->minlen )
+        if( ssl->in.msglen < ssl->transform_in->minlen )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3546,7 +3545,7 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
 
 #if defined(MBEDTLS_SSL_PROTO_SSL3)
         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 &&
-            ssl->in_msglen > ssl->transform_in->minlen + MBEDTLS_SSL_MAX_CONTENT_LEN )
+            ssl->in.msglen > ssl->transform_in->minlen + MBEDTLS_SSL_MAX_CONTENT_LEN )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3558,7 +3557,7 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
          * TLS encrypted messages can have up to 256 bytes of padding
          */
         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 &&
-            ssl->in_msglen > ssl->transform_in->minlen +
+            ssl->in.msglen > ssl->transform_in->minlen +
                              MBEDTLS_SSL_MAX_CONTENT_LEN + 256 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
@@ -3576,10 +3575,10 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
     {
-        unsigned int rec_epoch = ( ssl->in_ctr[0] << 8 ) | ssl->in_ctr[1];
+        unsigned int rec_epoch = ( ssl->in.ctr[0] << 8 ) | ssl->in.ctr[1];
 
         /* Drop unexpected ChangeCipherSpec messages */
-        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
+        if( ssl->in.msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
             ssl->state != MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC &&
             ssl->state != MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC )
         {
@@ -3589,7 +3588,7 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
 
         /* Drop unexpected ApplicationData records,
          * except at the beginning of renegotiations */
-        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA &&
+        if( ssl->in.msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA &&
             ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER
 #if defined(MBEDTLS_SSL_RENEGOTIATION)
             && ! ( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
@@ -3618,9 +3617,9 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
             if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
                 ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER &&
                 rec_epoch == 0 &&
-                ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
-                ssl->in_left > 13 &&
-                ssl->in_buf[13] == MBEDTLS_SSL_HS_CLIENT_HELLO )
+                ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
+                ssl->in.left > 13 &&
+                ssl->in.buf[13] == MBEDTLS_SSL_HS_CLIENT_HELLO )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "possible client reconnect "
                                             "from the same port" ) );
@@ -3654,7 +3653,7 @@ static int ssl_prepare_record_content( mbedtls_ssl_context *ssl )
     int ret, done = 0;
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "input record from network",
-                   ssl->in_hdr, mbedtls_ssl_hdr_len( ssl ) + ssl->in_msglen );
+                   ssl->in.hdr, mbedtls_ssl_hdr_len( ssl ) + ssl->in.msglen );
 
 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
     if( mbedtls_ssl_hw_record_read != NULL )
@@ -3681,9 +3680,9 @@ static int ssl_prepare_record_content( mbedtls_ssl_context *ssl )
         }
 
         MBEDTLS_SSL_DEBUG_BUF( 4, "input payload after decrypt",
-                       ssl->in_msg, ssl->in_msglen );
+                       ssl->in.msg, ssl->in.msglen );
 
-        if( ssl->in_msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
+        if( ssl->in.msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3747,7 +3746,7 @@ int mbedtls_ssl_read_record( mbedtls_ssl_context *ssl )
             return( ret );
         }
 
-        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
+        if( ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
         {
             mbedtls_ssl_update_handshake_status( ssl );
         }
@@ -3800,9 +3799,9 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
     if( ssl->in_hslen != 0 )
     {
         /* Hard assertion to be sure that no application data
-         * is in flight, as corrupting ssl->in_msglen during
-         * ssl->in_offt != NULL is fatal. */
-        if( ssl->in_offt != NULL )
+         * is in flight, as corrupting ssl->in.msglen during
+         * ssl->in.offt != NULL is fatal. */
+        if( ssl->in.offt != NULL )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
@@ -3829,31 +3828,31 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
          *     bounds after handling a DTLS message with an unexpected
          *     sequence number, see mbedtls_ssl_prepare_handshake_record.
          */
-        if( ssl->in_hslen < ssl->in_msglen )
+        if( ssl->in_hslen < ssl->in.msglen )
         {
-            ssl->in_msglen -= ssl->in_hslen;
-            memmove( ssl->in_msg, ssl->in_msg + ssl->in_hslen,
-                     ssl->in_msglen );
+            ssl->in.msglen -= ssl->in_hslen;
+            memmove( ssl->in.msg, ssl->in.msg + ssl->in_hslen,
+                     ssl->in.msglen );
 
             MBEDTLS_SSL_DEBUG_BUF( 4, "remaining content in record",
-                                   ssl->in_msg, ssl->in_msglen );
+                                   ssl->in.msg, ssl->in.msglen );
         }
         else
         {
-            ssl->in_msglen = 0;
+            ssl->in.msglen = 0;
         }
 
         ssl->in_hslen   = 0;
     }
     /* Case (4): Application data */
-    else if( ssl->in_offt != NULL )
+    else if( ssl->in.offt != NULL )
     {
         return( 0 );
     }
     /* Everything else (CCS & Alerts) */
     else
     {
-        ssl->in_msglen = 0;
+        ssl->in.msglen = 0;
     }
 
     /*
@@ -3863,7 +3862,7 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
      *
      */
 
-    if( ssl->in_msglen > 0 )
+    if( ssl->in.msglen > 0 )
     {
         /* There's something left to be processed in the current record. */
         return( 0 );
@@ -3892,7 +3891,7 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
             if( ret == MBEDTLS_ERR_SSL_UNEXPECTED_RECORD )
             {
                 /* Skip unexpected record (but not whole datagram) */
-                ssl->next_record_offset = ssl->in_msglen
+                ssl->next_record_offset = ssl->in.msglen
                                         + mbedtls_ssl_hdr_len( ssl );
 
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding unexpected record "
@@ -3902,7 +3901,7 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
             {
                 /* Skip invalid record and the rest of the datagram */
                 ssl->next_record_offset = 0;
-                ssl->in_left = 0;
+                ssl->in.left = 0;
 
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding invalid record "
                                             "(header)" ) );
@@ -3919,7 +3918,7 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
      * Read and optionally decrypt the message contents
      */
     if( ( ret = mbedtls_ssl_fetch_input( ssl,
-                                 mbedtls_ssl_hdr_len( ssl ) + ssl->in_msglen ) ) != 0 )
+                                 mbedtls_ssl_hdr_len( ssl ) + ssl->in.msglen ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
         return( ret );
@@ -3928,11 +3927,10 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
     /* Done reading this record, get ready for the next one */
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
-        ssl->next_record_offset = ssl->in_msglen + mbedtls_ssl_hdr_len( ssl );
+        ssl->next_record_offset = ssl->in.msglen + mbedtls_ssl_hdr_len( ssl );
     else
 #endif
-        ssl->in_left = 0;
-
+        ssl->in.left = 0;
     if( ( ret = ssl_prepare_record_content( ssl ) ) != 0 )
     {
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
@@ -3972,7 +3970,7 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
                  * dismissal of the whole datagram. */
 
                 ssl->next_record_offset = 0;
-                ssl->in_left = 0;
+                ssl->in.left = 0;
 
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding invalid record (mac)" ) );
                 goto read_record_header;
@@ -4016,8 +4014,8 @@ int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
         ssl->handshake != NULL &&
         ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
     {
-        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
-                ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
+        if( ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
+                ssl->in.msg[0] == MBEDTLS_SSL_HS_FINISHED )
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "received retransmit of last flight" ) );
 
@@ -4046,7 +4044,7 @@ int mbedtls_ssl_handle_message_type( mbedtls_ssl_context *ssl )
     /*
      * Handle particular types of records
      */
-    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         if( ( ret = mbedtls_ssl_prepare_handshake_record( ssl ) ) != 0 )
         {
@@ -4054,31 +4052,31 @@ int mbedtls_ssl_handle_message_type( mbedtls_ssl_context *ssl )
         }
     }
 
-    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
+    if( ssl->in.msgtype == MBEDTLS_SSL_MSG_ALERT )
     {
         MBEDTLS_SSL_DEBUG_MSG( 2, ( "got an alert message, type: [%d:%d]",
-                       ssl->in_msg[0], ssl->in_msg[1] ) );
+                       ssl->in.msg[0], ssl->in.msg[1] ) );
 
         /*
          * Ignore non-fatal alerts, except close_notify and no_renegotiation
          */
-        if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL )
+        if( ssl->in.msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "is a fatal alert message (msg %d)",
-                           ssl->in_msg[1] ) );
+                           ssl->in.msg[1] ) );
             return( MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE );
         }
 
-        if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
-            ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY )
+        if( ssl->in.msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
+            ssl->in.msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY )
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a close notify message" ) );
             return( MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY );
         }
 
 #if defined(MBEDTLS_SSL_RENEGOTIATION_ENABLED)
-        if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
-            ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION )
+        if( ssl->in.msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
+            ssl->in.msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION )
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a SSLv3 no_cert" ) );
             /* Will be handled when trying to parse ServerHello */
@@ -4089,8 +4087,8 @@ int mbedtls_ssl_handle_message_type( mbedtls_ssl_context *ssl )
 #if defined(MBEDTLS_SSL_PROTO_SSL3) && defined(MBEDTLS_SSL_SRV_C)
         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 &&
             ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
-            ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
-            ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
+            ssl->in.msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
+            ssl->in.msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a SSLv3 no_cert" ) );
             /* Will be handled in mbedtls_ssl_parse_certificate() */
@@ -4131,10 +4129,10 @@ int mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> send alert message" ) );
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "send alert level=%u message=%u", level, message ));
 
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
-    ssl->out_msglen = 2;
-    ssl->out_msg[0] = level;
-    ssl->out_msg[1] = message;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_ALERT;
+    ssl->out.msglen = 2;
+    ssl->out.msg[0] = level;
+    ssl->out.msg[1] = message;
 
     if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
     {
@@ -4237,10 +4235,10 @@ int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
         if( mbedtls_ssl_own_cert( ssl )  == NULL &&
             ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
         {
-            ssl->out_msglen  = 2;
-            ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
-            ssl->out_msg[0]  = MBEDTLS_SSL_ALERT_LEVEL_WARNING;
-            ssl->out_msg[1]  = MBEDTLS_SSL_ALERT_MSG_NO_CERT;
+            ssl->out.msglen  = 2;
+            ssl->out.msgtype = MBEDTLS_SSL_MSG_ALERT;
+            ssl->out.msg[0]  = MBEDTLS_SSL_ALERT_LEVEL_WARNING;
+            ssl->out.msg[1]  = MBEDTLS_SSL_ALERT_MSG_NO_CERT;
 
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "got no certificate to send" ) );
             goto write_msg;
@@ -4283,21 +4281,21 @@ int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
             return( MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE );
         }
 
-        ssl->out_msg[i    ] = (unsigned char)( n >> 16 );
-        ssl->out_msg[i + 1] = (unsigned char)( n >>  8 );
-        ssl->out_msg[i + 2] = (unsigned char)( n       );
+        ssl->out.msg[i    ] = (unsigned char)( n >> 16 );
+        ssl->out.msg[i + 1] = (unsigned char)( n >>  8 );
+        ssl->out.msg[i + 2] = (unsigned char)( n       );
 
-        i += 3; memcpy( ssl->out_msg + i, crt->raw.p, n );
+        i += 3; memcpy( ssl->out.msg + i, crt->raw.p, n );
         i += n; crt = crt->next;
     }
 
-    ssl->out_msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );
-    ssl->out_msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );
-    ssl->out_msg[6]  = (unsigned char)( ( i - 7 )       );
+    ssl->out.msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );
+    ssl->out.msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );
+    ssl->out.msg[6]  = (unsigned char)( ( i - 7 )       );
 
-    ssl->out_msglen  = i;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE;
+    ssl->out.msglen  = i;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE;
 
 #if defined(MBEDTLS_SSL_PROTO_SSL3) && defined(MBEDTLS_SSL_CLI_C)
 write_msg:
@@ -4378,10 +4376,10 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
     if( ssl->conf->endpoint  == MBEDTLS_SSL_IS_SERVER &&
         ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
     {
-        if( ssl->in_msglen  == 2                        &&
-            ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT            &&
-            ssl->in_msg[0]  == MBEDTLS_SSL_ALERT_LEVEL_WARNING  &&
-            ssl->in_msg[1]  == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
+        if( ssl->in.msglen  == 2                        &&
+            ssl->in.msgtype == MBEDTLS_SSL_MSG_ALERT            &&
+            ssl->in.msg[0]  == MBEDTLS_SSL_ALERT_LEVEL_WARNING  &&
+            ssl->in.msg[1]  == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "SSLv3 client has no certificate" ) );
 
@@ -4403,9 +4401,9 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
         ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
     {
         if( ssl->in_hslen   == 3 + mbedtls_ssl_hs_hdr_len( ssl ) &&
-            ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    &&
-            ssl->in_msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   &&
-            memcmp( ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ), "\0\0\0", 3 ) == 0 )
+            ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    &&
+            ssl->in.msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   &&
+            memcmp( ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl ), "\0\0\0", 3 ) == 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLSv1 client has no certificate" ) );
 
@@ -4423,7 +4421,7 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
           MBEDTLS_SSL_PROTO_TLS1_2 */
 #endif /* MBEDTLS_SSL_SRV_C */
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -4431,7 +4429,7 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
-    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||
+    if( ssl->in.msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||
         ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 3 + 3 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
@@ -4445,9 +4443,9 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
     /*
      * Same message structure as in mbedtls_ssl_write_certificate()
      */
-    n = ( ssl->in_msg[i+1] << 8 ) | ssl->in_msg[i+2];
+    n = ( ssl->in.msg[i+1] << 8 ) | ssl->in.msg[i+2];
 
-    if( ssl->in_msg[i] != 0 ||
+    if( ssl->in.msg[i] != 0 ||
         ssl->in_hslen != n + 3 + mbedtls_ssl_hs_hdr_len( ssl ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
@@ -4479,7 +4477,7 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
 
     while( i < ssl->in_hslen )
     {
-        if( ssl->in_msg[i] != 0 )
+        if( ssl->in.msg[i] != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -4487,8 +4485,8 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
             return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
         }
 
-        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )
-            | (unsigned int) ssl->in_msg[i + 2];
+        n = ( (unsigned int) ssl->in.msg[i + 1] << 8 )
+            | (unsigned int) ssl->in.msg[i + 2];
         i += 3;
 
         if( n < 128 || i + n > ssl->in_hslen )
@@ -4500,7 +4498,7 @@ int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
         }
 
         ret = mbedtls_x509_crt_parse_der( ssl->session_negotiate->peer_cert,
-                                  ssl->in_msg + i, n );
+                                  ssl->in.msg + i, n );
         switch( ret )
         {
         case 0: /*ok*/
@@ -4706,9 +4704,9 @@ int mbedtls_ssl_write_change_cipher_spec( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write change cipher spec" ) );
 
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
-    ssl->out_msglen  = 1;
-    ssl->out_msg[0]  = 1;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
+    ssl->out.msglen  = 1;
+    ssl->out.msg[0]  = 1;
 
     ssl->state++;
 
@@ -4735,7 +4733,7 @@ int mbedtls_ssl_parse_change_cipher_spec( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -4743,7 +4741,7 @@ int mbedtls_ssl_parse_change_cipher_spec( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
-    if( ssl->in_msglen != 1 || ssl->in_msg[0] != 1 )
+    if( ssl->in.msglen != 1 || ssl->in.msg[0] != 1 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -4777,18 +4775,18 @@ int mbedtls_ssl_parse_change_cipher_spec( mbedtls_ssl_context *ssl )
     }
     else
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
-    memset( ssl->in_ctr, 0, 8 );
+    memset( ssl->in.ctr, 0, 8 );
 
     /*
      * Set the in_msg pointer to the correct location based on IV length
      */
     if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
     {
-        ssl->in_msg = ssl->in_iv + ssl->transform_negotiate->ivlen -
+        ssl->in.msg= ssl->in.iv + ssl->transform_negotiate->ivlen -
                       ssl->transform_negotiate->fixed_ivlen;
     }
     else
-        ssl->in_msg = ssl->in_iv;
+        ssl->in.msg= ssl->in.iv;
 
 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
     if( mbedtls_ssl_hw_record_activate != NULL )
@@ -5244,13 +5242,13 @@ int mbedtls_ssl_write_finished( mbedtls_ssl_context *ssl )
      */
     if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
     {
-        ssl->out_msg = ssl->out_iv + ssl->transform_negotiate->ivlen -
+        ssl->out.msg = ssl->out.iv + ssl->transform_negotiate->ivlen -
                        ssl->transform_negotiate->fixed_ivlen;
     }
     else
-        ssl->out_msg = ssl->out_iv;
+        ssl->out.msg = ssl->out.iv;
 
-    ssl->handshake->calc_finished( ssl, ssl->out_msg + 4, ssl->conf->endpoint );
+    ssl->handshake->calc_finished( ssl, ssl->out.msg + 4, ssl->conf->endpoint );
 
     /*
      * RFC 5246 7.4.9 (Page 63) says 12 is the default length and ciphersuites
@@ -5262,12 +5260,12 @@ int mbedtls_ssl_write_finished( mbedtls_ssl_context *ssl )
 
 #if defined(MBEDTLS_SSL_RENEGOTIATION)
     ssl->verify_data_len = hash_len;
-    memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );
+    memcpy( ssl->own_verify_data, ssl->out.msg + 4, hash_len );
 #endif
 
-    ssl->out_msglen  = 4 + hash_len;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_FINISHED;
+    ssl->out.msglen  = 4 + hash_len;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_FINISHED;
 
     /*
      * In case of session resuming, invert the client and server
@@ -5300,14 +5298,14 @@ int mbedtls_ssl_write_finished( mbedtls_ssl_context *ssl )
 
         /* Remember current epoch settings for resending */
         ssl->handshake->alt_transform_out = ssl->transform_out;
-        memcpy( ssl->handshake->alt_out_ctr, ssl->out_ctr, 8 );
+        memcpy( ssl->handshake->alt_out_ctr, ssl->out.ctr, 8 );
 
         /* Set sequence_number to zero */
-        memset( ssl->out_ctr + 2, 0, 6 );
+        memset( ssl->out.ctr + 2, 0, 6 );
 
         /* Increment epoch */
         for( i = 2; i > 0; i-- )
-            if( ++ssl->out_ctr[i - 1] != 0 )
+            if( ++ssl->out.ctr[i - 1] != 0 )
                 break;
 
         /* The loop goes to its end iff the counter is wrapping */
@@ -5319,7 +5317,7 @@ int mbedtls_ssl_write_finished( mbedtls_ssl_context *ssl )
     }
     else
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
-    memset( ssl->out_ctr, 0, 8 );
+    memset( ssl->out.ctr, 0, 8 );
 
     ssl->transform_out = ssl->transform_negotiate;
     ssl->session_out = ssl->session_negotiate;
@@ -5373,7 +5371,7 @@ int mbedtls_ssl_parse_finished( mbedtls_ssl_context *ssl )
         return( ret );
     }
 
-    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
+    if( ssl->in.msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -5389,7 +5387,7 @@ int mbedtls_ssl_parse_finished( mbedtls_ssl_context *ssl )
 #endif
         hash_len = 12;
 
-    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_FINISHED ||
+    if( ssl->in.msg[0] != MBEDTLS_SSL_HS_FINISHED ||
         ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) + hash_len )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
@@ -5398,7 +5396,7 @@ int mbedtls_ssl_parse_finished( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_BAD_HS_FINISHED );
     }
 
-    if( mbedtls_ssl_safer_memcmp( ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ),
+    if( mbedtls_ssl_safer_memcmp( ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl ),
                       buf, hash_len ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
@@ -5607,59 +5605,91 @@ void mbedtls_ssl_init( mbedtls_ssl_context *ssl )
 }
 
 /*
- * Setup an SSL context
+ * (Re)allocate a buffer for an ssl record
+ *
+ * If rec->buf is already allocated, the content is copied into the
+ * new allocation up to the limit of either the old or new allocation,
+ * whichever is smaller.
+ *
+ * max_content_len may not exceed 16384
+ * (MBEDTLS_SSL_MAX_CONTENT_LEN) or be less than 512.
+ *
+ * If the call fails, caller must destroy the ssl and free any
+ * non-null ssl->*buf
  */
-int mbedtls_ssl_setup( mbedtls_ssl_context *ssl,
-                       const mbedtls_ssl_config *conf )
+int mbedtls_ssl_alloc_record_buf( mbedtls_ssl_context *ssl,
+		                  mbedtls_ssl_record *rec,
+                                  size_t max_content_len )
 {
-    int ret;
-    const size_t len = MBEDTLS_SSL_BUFFER_LEN;
+    size_t len, min;
+    unsigned char *buf;
 
-    ssl->conf = conf;
+    (void)ssl;
 
-    /*
-     * Prepare base structures
-     */
-    if( ( ssl-> in_buf = mbedtls_calloc( 1, len ) ) == NULL ||
-        ( ssl->out_buf = mbedtls_calloc( 1, len ) ) == NULL )
-    {
-        MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed", len ) );
-        mbedtls_free( ssl->in_buf );
-        ssl->in_buf = NULL;
+    if (max_content_len < MBEDTLS_SSL_BUFFER_MIN)
+	max_content_len = MBEDTLS_SSL_BUFFER_MIN;
+
+    if( max_content_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
+        max_content_len = MBEDTLS_SSL_MAX_CONTENT_LEN;
+
+    min = len = max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD;
+
+    if ( rec->max_content_len &&
+         rec->max_content_len + (size_t)MBEDTLS_SSL_BUFFER_OVERHEAD < len )
+            min = rec->max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD;
+
+    buf = mbedtls_calloc( 1, len );
+    if( !buf ) {
         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
     }
 
+    if( rec->buf ) {
+	    memcpy(buf, rec->buf, min);
+	    /* if offt is in use, also fix it up */
+	    if (rec->offt)
+		    rec->offt = (rec->offt - rec->buf) + buf;
+	    mbedtls_free(rec->buf);
+    }
+    MBEDTLS_SSL_DEBUG_MSG( 2, ( "%s: realloc %s: %u -> %u\n", __func__,
+			   rec == &ssl->in ? "in" : "out",
+			   (unsigned int)rec->max_content_len,
+			   (unsigned int)max_content_len ) );
+
+    rec->buf = buf;
+    rec->max_content_len = max_content_len;
+
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
-    if( conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
+    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
     {
-        ssl->out_hdr = ssl->out_buf;
-        ssl->out_ctr = ssl->out_buf +  3;
-        ssl->out_len = ssl->out_buf + 11;
-        ssl->out_iv  = ssl->out_buf + 13;
-        ssl->out_msg = ssl->out_buf + 13;
-
-        ssl->in_hdr = ssl->in_buf;
-        ssl->in_ctr = ssl->in_buf +  3;
-        ssl->in_len = ssl->in_buf + 11;
-        ssl->in_iv  = ssl->in_buf + 13;
-        ssl->in_msg = ssl->in_buf + 13;
+        rec->hdr = buf;
+        rec->ctr = buf +  3;
+        rec->len = buf + 11;
+        rec->iv  = buf + 13;
+        rec->msg = buf + 13;
     }
     else
 #endif
     {
-        ssl->out_ctr = ssl->out_buf;
-        ssl->out_hdr = ssl->out_buf +  8;
-        ssl->out_len = ssl->out_buf + 11;
-        ssl->out_iv  = ssl->out_buf + 13;
-        ssl->out_msg = ssl->out_buf + 13;
-
-        ssl->in_ctr = ssl->in_buf;
-        ssl->in_hdr = ssl->in_buf +  8;
-        ssl->in_len = ssl->in_buf + 11;
-        ssl->in_iv  = ssl->in_buf + 13;
-        ssl->in_msg = ssl->in_buf + 13;
+        rec->ctr = buf;
+        rec->hdr = buf +  8;
+        rec->len = buf + 11;
+        rec->iv  = buf + 13;
+        rec->msg = buf + 13;
     }
 
+    return( 0 );
+}
+
+/*
+ * Setup an SSL context
+ */
+int mbedtls_ssl_setup( mbedtls_ssl_context *ssl,
+                       const mbedtls_ssl_config *conf )
+{
+    int ret;
+
+    ssl->conf = conf;
+
     if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
         return( ret );
 
@@ -5692,13 +5722,13 @@ static int ssl_session_reset_int( mbedtls_ssl_context *ssl, int partial )
 #endif
     ssl->secure_renegotiation = MBEDTLS_SSL_LEGACY_RENEGOTIATION;
 
-    ssl->in_offt = NULL;
+    ssl->in.offt = NULL;
 
-    ssl->in_msg = ssl->in_buf + 13;
-    ssl->in_msgtype = 0;
-    ssl->in_msglen = 0;
+    ssl->in.msg= ssl->in.buf + 13;
+    ssl->in.msgtype = 0;
+    ssl->in.msglen = 0;
     if( partial == 0 )
-        ssl->in_left = 0;
+        ssl->in.left = 0;
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     ssl->next_record_offset = 0;
     ssl->in_epoch = 0;
@@ -5712,10 +5742,10 @@ static int ssl_session_reset_int( mbedtls_ssl_context *ssl, int partial )
 
     ssl->keep_current_message = 0;
 
-    ssl->out_msg = ssl->out_buf + 13;
-    ssl->out_msgtype = 0;
-    ssl->out_msglen = 0;
-    ssl->out_left = 0;
+    ssl->out.msg = ssl->out.buf + 13;
+    ssl->out.msgtype = 0;
+    ssl->out.msglen = 0;
+    ssl->out.left = 0;
 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
     if( ssl->split_done != MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED )
         ssl->split_done = 0;
@@ -5724,9 +5754,12 @@ static int ssl_session_reset_int( mbedtls_ssl_context *ssl, int partial )
     ssl->transform_in = NULL;
     ssl->transform_out = NULL;
 
-    memset( ssl->out_buf, 0, MBEDTLS_SSL_BUFFER_LEN );
-    if( partial == 0 )
-        memset( ssl->in_buf, 0, MBEDTLS_SSL_BUFFER_LEN );
+    if( ssl->out.buf )
+        memset( ssl->out.buf, 0, ssl->out.max_content_len +
+                             MBEDTLS_SSL_BUFFER_OVERHEAD );
+    if( partial == 0  && ssl->in.buf )
+        memset( ssl->in.buf, 0, ssl->in.max_content_len
+                                + MBEDTLS_SSL_BUFFER_OVERHEAD );
 
 #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
     if( mbedtls_ssl_hw_record_reset != NULL )
@@ -6404,7 +6437,7 @@ void mbedtls_ssl_conf_export_keys_cb( mbedtls_ssl_config *conf,
  */
 size_t mbedtls_ssl_get_bytes_avail( const mbedtls_ssl_context *ssl )
 {
-    return( ssl->in_offt == NULL ? 0 : ssl->in_msglen );
+    return( ssl->in.offt == NULL ? 0 : ssl->in.msglen );
 }
 
 uint32_t mbedtls_ssl_get_verify_result( const mbedtls_ssl_context *ssl )
@@ -6604,9 +6637,9 @@ static int ssl_write_hello_request( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello request" ) );
 
-    ssl->out_msglen  = 4;
-    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
-    ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_REQUEST;
+    ssl->out.msglen  = 4;
+    ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
+    ssl->out.msg[0]  = MBEDTLS_SSL_HS_HELLO_REQUEST;
 
     if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
     {
@@ -6686,7 +6719,7 @@ int mbedtls_ssl_renegotiate( mbedtls_ssl_context *ssl )
         ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;
 
         /* Did we already try/start sending HelloRequest? */
-        if( ssl->out_left != 0 )
+        if( ssl->out.left != 0 )
             return( mbedtls_ssl_flush_output( ssl ) );
 
         return( ssl_write_hello_request( ssl ) );
@@ -6738,9 +6771,9 @@ static int ssl_check_ctr_renegotiate( mbedtls_ssl_context *ssl )
         return( 0 );
     }
 
-    in_ctr_cmp = memcmp( ssl->in_ctr + ep_len,
+    in_ctr_cmp = memcmp( ssl->in.ctr + ep_len,
                         ssl->conf->renego_period + ep_len, 8 - ep_len );
-    out_ctr_cmp = memcmp( ssl->out_ctr + ep_len,
+    out_ctr_cmp = memcmp( ssl->out.ctr + ep_len,
                           ssl->conf->renego_period + ep_len, 8 - ep_len );
 
     if( in_ctr_cmp <= 0 && out_ctr_cmp <= 0 )
@@ -6821,14 +6854,14 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
      *
      * Instead of
      *
-     * - Manually checking whether ssl->in_offt is NULL
+     * - Manually checking whether ssl->in.offt is NULL
      * - Fetching a new record if yes
-     * - Setting ssl->in_offt if one finds an application record
+     * - Setting ssl->in.offt if one finds an application record
      * - Resetting keep_current_message after handling the application data
      *
      * one should
      *
-     * - Adapt read_record to set ssl->in_offt automatically
+     * - Adapt read_record to set ssl->in.offt automatically
      *   when a new application data record is processed.
      * - Always call mbedtls_ssl_read_record here.
      *
@@ -6849,7 +6882,7 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
      *
      */
 
-    if( ssl->in_offt == NULL )
+    if( ssl->in.offt == NULL )
     {
         /* Start timer if not already running */
         if( ssl->f_get_timer != NULL &&
@@ -6867,8 +6900,8 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
             return( ret );
         }
 
-        if( ssl->in_msglen  == 0 &&
-            ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA )
+        if( ssl->in.msglen  == 0 &&
+            ssl->in.msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA )
         {
             /*
              * OpenSSL sends empty messages to randomize the IV
@@ -6883,7 +6916,7 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
             }
         }
 
-        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
+        if( ssl->in.msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "received handshake message" ) );
 
@@ -6895,7 +6928,7 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
 
 #if defined(MBEDTLS_SSL_CLI_C)
             if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
-                ( ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
+                ( ssl->in.msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
                   ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ) )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake received (not HelloRequest)" ) );
@@ -6911,7 +6944,7 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
 
 #if defined(MBEDTLS_SSL_SRV_C)
             if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
-                ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
+                ssl->in.msg[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake received (not ClientHello)" ) );
 
@@ -7009,19 +7042,19 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
 #endif /* MBEDTLS_SSL_RENEGOTIATION */
 
         /* Fatal and closure alerts handled by mbedtls_ssl_read_record() */
-        if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
+        if( ssl->in.msgtype == MBEDTLS_SSL_MSG_ALERT )
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( "ignoring non-fatal non-closure alert" ) );
             return( MBEDTLS_ERR_SSL_WANT_READ );
         }
 
-        if( ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
+        if( ssl->in.msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad application data message" ) );
             return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
         }
 
-        ssl->in_offt = ssl->in_msg;
+        ssl->in.offt = ssl->in.msg;
 
         /* We're going to return something now, cancel timer,
          * except if handshake (renegotiation) is in progress */
@@ -7046,22 +7079,22 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
     }
 
-    n = ( len < ssl->in_msglen )
-        ? len : ssl->in_msglen;
+    n = ( len < ssl->in.msglen )
+        ? len : ssl->in.msglen;
 
-    memcpy( buf, ssl->in_offt, n );
-    ssl->in_msglen -= n;
+    memcpy( buf, ssl->in.offt, n );
+    ssl->in.msglen -= n;
 
-    if( ssl->in_msglen == 0 )
+    if( ssl->in.msglen == 0 )
     {
         /* all bytes consumed */
-        ssl->in_offt = NULL;
+        ssl->in.offt = NULL;
         ssl->keep_current_message = 0;
     }
     else
     {
         /* more data available */
-        ssl->in_offt += n;
+        ssl->in.offt += n;
     }
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= read" ) );
@@ -7080,7 +7113,7 @@ static int ssl_write_real( mbedtls_ssl_context *ssl,
 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
     size_t max_len = mbedtls_ssl_get_max_frag_len( ssl );
 #else
-    size_t max_len = MBEDTLS_SSL_MAX_CONTENT_LEN;
+    size_t max_len = ssl->out.max_content_len;
 #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
     if( len > max_len )
     {
@@ -7097,7 +7130,7 @@ static int ssl_write_real( mbedtls_ssl_context *ssl,
             len = max_len;
     }
 
-    if( ssl->out_left != 0 )
+    if( ssl->out.left != 0 )
     {
         if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
         {
@@ -7107,9 +7140,9 @@ static int ssl_write_real( mbedtls_ssl_context *ssl,
     }
     else
     {
-        ssl->out_msglen  = len;
-        ssl->out_msgtype = MBEDTLS_SSL_MSG_APPLICATION_DATA;
-        memcpy( ssl->out_msg, buf, len );
+        ssl->out.msglen  = len;
+        ssl->out.msgtype = MBEDTLS_SSL_MSG_APPLICATION_DATA;
+        memcpy( ssl->out.msg, buf, len );
 
         if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
         {
@@ -7211,7 +7244,7 @@ int mbedtls_ssl_close_notify( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write close notify" ) );
 
-    if( ssl->out_left != 0 )
+    if( ssl->out.left != 0 )
         return( mbedtls_ssl_flush_output( ssl ) );
 
     if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
@@ -7369,16 +7402,16 @@ void mbedtls_ssl_free( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> free" ) );
 
-    if( ssl->out_buf != NULL )
+    if( ssl->out.buf != NULL )
     {
-        mbedtls_zeroize( ssl->out_buf, MBEDTLS_SSL_BUFFER_LEN );
-        mbedtls_free( ssl->out_buf );
+        mbedtls_zeroize( ssl->out.buf, MBEDTLS_SSL_BUFFER_LEN );
+        mbedtls_free( ssl->out.buf );
     }
 
-    if( ssl->in_buf != NULL )
+    if( ssl->in.buf != NULL )
     {
-        mbedtls_zeroize( ssl->in_buf, MBEDTLS_SSL_BUFFER_LEN );
-        mbedtls_free( ssl->in_buf );
+        mbedtls_zeroize( ssl->in.buf, MBEDTLS_SSL_BUFFER_LEN );
+        mbedtls_free( ssl->in.buf );
     }
 
 #if defined(MBEDTLS_ZLIB_SUPPORT)
diff --git a/tests/suites/test_suite_ssl.function b/tests/suites/test_suite_ssl.function
index 60683afee..61799c337 100644
--- a/tests/suites/test_suite_ssl.function
+++ b/tests/suites/test_suite_ssl.function
@@ -28,12 +28,12 @@ void ssl_dtls_replay( char *prevs, char *new, int ret )
     for( ; end_prevs - prevs >= 13; prevs += 13 )
     {
         prevs[12] = '\0';
-        unhexify( ssl.in_ctr + 2, prevs );
+        unhexify( ssl.in.ctr + 2, prevs );
         mbedtls_ssl_dtls_replay_update( &ssl );
     }
 
     /* Check new number */
-    unhexify( ssl.in_ctr + 2, new );
+    unhexify( ssl.in.ctr + 2, new );
     TEST_ASSERT( mbedtls_ssl_dtls_replay_check( &ssl ) == ret );
 
     mbedtls_ssl_free( &ssl );
@@ -52,4 +52,4 @@ void ssl_set_hostname_twice( char *hostname0, char *hostname1 )
 
     mbedtls_ssl_free( &ssl );
 }
-/* END_CASE */
\ No newline at end of file
+/* END_CASE */

From d69270518f3b43f4b418167a002e7dd5cc53a694 Mon Sep 17 00:00:00 2001
From: Andy Green <andy@warmcat.com>
Date: Wed, 13 Dec 2017 15:11:51 +0800
Subject: [PATCH 2/4] dynamic content length: convert MBEDTLS_SSL_BUFFER_LEN to
 be computed at runtime

For most cases, MBEDTLS_SSL_BUFFER_LEN is changed to use ssl->in.max_content_len
and ssl->out.max_content_len.

For compression buffers, they are allocated at MBEDTLS_SSL_BUFFER_LEN.

Signed-off-by: Andy Green <andy@warmcat.com>
---
 library/ssl_cli.c | 34 +++++++++++++++++-----------------
 library/ssl_srv.c | 15 ++++++++-------
 library/ssl_tls.c | 53 ++++++++++++++++++++++++++++++++---------------------
 3 files changed, 57 insertions(+), 45 deletions(-)

diff --git a/library/ssl_cli.c b/library/ssl_cli.c
index b19449abd..47fb9459d 100644
--- a/library/ssl_cli.c
+++ b/library/ssl_cli.c
@@ -60,7 +60,7 @@ static void ssl_write_hostname_ext( mbedtls_ssl_context *ssl,
                                     size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
     size_t hostname_len;
 
     *olen = 0;
@@ -130,7 +130,7 @@ static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,
                                          size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
 
     *olen = 0;
 
@@ -174,7 +174,7 @@ static void ssl_write_signature_algorithms_ext( mbedtls_ssl_context *ssl,
                                                 size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
     size_t sig_alg_len = 0;
     const int *md;
 #if defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C)
@@ -259,7 +259,7 @@ static void ssl_write_supported_elliptic_curves_ext( mbedtls_ssl_context *ssl,
                                                      size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
     unsigned char *elliptic_curve_list = p + 6;
     size_t elliptic_curve_len = 0;
     const mbedtls_ecp_curve_info *info;
@@ -332,7 +332,7 @@ static void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,
                                                    size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
 
     *olen = 0;
 
@@ -365,7 +365,7 @@ static void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
 {
     int ret;
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
     size_t kkpp_len;
 
     *olen = 0;
@@ -475,7 +475,7 @@ static void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,
                                           unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
 
     *olen = 0;
 
@@ -507,7 +507,7 @@ static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
                                        unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
 
     *olen = 0;
 
@@ -541,7 +541,7 @@ static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                        unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
 
     *olen = 0;
 
@@ -575,7 +575,7 @@ static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                           unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
     size_t tlen = ssl->session_negotiate->ticket_len;
 
     *olen = 0;
@@ -619,7 +619,7 @@ static void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
                                 unsigned char *buf, size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
     size_t alpnlen = 0;
     const char **cur;
 
@@ -2092,7 +2092,7 @@ static int ssl_write_encrypted_pms( mbedtls_ssl_context *ssl,
     size_t len_bytes = ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ? 0 : 2;
     unsigned char *p = ssl->handshake->premaster + pms_offset;
 
-    if( offset + len_bytes > MBEDTLS_SSL_MAX_CONTENT_LEN )
+    if( offset + len_bytes > ssl->out.max_content_len )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small for encrypted pms" ) );
         return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
@@ -2135,7 +2135,7 @@ static int ssl_write_encrypted_pms( mbedtls_ssl_context *ssl,
     if( ( ret = mbedtls_pk_encrypt( &ssl->session_negotiate->peer_cert->pk,
                             p, ssl->handshake->pmslen,
                             ssl->out.msg + offset + len_bytes, olen,
-                            MBEDTLS_SSL_MAX_CONTENT_LEN - offset - len_bytes,
+                            ssl->out.max_content_len - offset - len_bytes,
                             ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_rsa_pkcs1_encrypt", ret );
@@ -2913,7 +2913,7 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
         i = 4;
         n = ssl->conf->psk_identity_len;
 
-        if( i + 2 + n > MBEDTLS_SSL_MAX_CONTENT_LEN )
+        if( i + 2 + n > ssl->out.max_content_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "psk identity too long or "
                                         "SSL buffer too short" ) );
@@ -2949,7 +2949,7 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
              */
             n = ssl->handshake->dhm_ctx.len;
 
-            if( i + 2 + n > MBEDTLS_SSL_MAX_CONTENT_LEN )
+            if( i + 2 + n > ssl->out.max_content_len )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( "psk identity or DHM size too long"
                                             " or SSL buffer too short" ) );
@@ -2978,7 +2978,7 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
              * ClientECDiffieHellmanPublic public;
              */
             ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx, &n,
-                    &ssl->out.msg[i], MBEDTLS_SSL_MAX_CONTENT_LEN - i,
+                    &ssl->out.msg[i], ssl->out.max_content_len - i,
                     ssl->conf->f_rng, ssl->conf->p_rng );
             if( ret != 0 )
             {
@@ -3019,7 +3019,7 @@ static int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )
         i = 4;
 
         ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
-                ssl->out.msg + i, MBEDTLS_SSL_MAX_CONTENT_LEN - i, &n,
+                ssl->out.msg + i, ssl->out.max_content_len - i, &n,
                 ssl->conf->f_rng, ssl->conf->p_rng );
         if( ret != 0 )
         {
diff --git a/library/ssl_srv.c b/library/ssl_srv.c
index 5875f3071..96a3135b1 100644
--- a/library/ssl_srv.c
+++ b/library/ssl_srv.c
@@ -1301,7 +1301,7 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
     else
 #endif
     {
-        if( msg_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
+        if( msg_len > ssl->in.max_content_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
             return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
@@ -2233,7 +2233,7 @@ static void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
 {
     int ret;
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
     size_t kkpp_len;
 
     *olen = 0;
@@ -2340,7 +2340,8 @@ static int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
     cookie_len_byte = p++;
 
     if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,
-                                     &p, ssl->out.buf + MBEDTLS_SSL_BUFFER_LEN,
+                                     &p, ssl->out.buf + ssl->out.max_content_len +
+                                         MBEDTLS_SSL_BUFFER_OVERHEAD,
                                      ssl->cli_id, ssl->cli_id_len ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "f_cookie_write", ret );
@@ -2636,7 +2637,7 @@ static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
     size_t dn_size, total_dn_size; /* excluding length bytes */
     size_t ct_len, sa_len; /* including length bytes */
     unsigned char *buf, *p;
-    const unsigned char * const end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char * const end = ssl->out.msg + ssl->out.max_content_len;
     const mbedtls_x509_crt *crt;
     int authmode;
 
@@ -2883,7 +2884,7 @@ static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
     {
-        const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+        const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
 
         ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
                 p, end - p, &len, ssl->conf->f_rng, ssl->conf->p_rng );
@@ -3007,7 +3008,7 @@ static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
         }
 
         if( ( ret = mbedtls_ecdh_make_params( &ssl->handshake->ecdh_ctx, &len,
-                                      p, MBEDTLS_SSL_MAX_CONTENT_LEN - n,
+                                      p, ssl->out.max_content_len - n,
                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_make_params", ret );
@@ -3965,7 +3966,7 @@ static int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
     if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,
                                 ssl->session_negotiate,
                                 ssl->out.msg + 10,
-                                ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN,
+                                ssl->out.msg + ssl->out.max_content_len,
                                 &tlen, &lifetime ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_write", ret );
diff --git a/library/ssl_tls.c b/library/ssl_tls.c
index e6a5e83cc..4b99012f8 100644
--- a/library/ssl_tls.c
+++ b/library/ssl_tls.c
@@ -1863,14 +1863,14 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
              * Padding is guaranteed to be incorrect if:
              *   1. padlen >= ssl->in.msglen
              *
-             *   2. padding_idx >= MBEDTLS_SSL_MAX_CONTENT_LEN +
+             *   2. padding_idx >= ssl->max_content_len +
              *                     ssl->transform_in->maclen
              *
              * In both cases we reset padding_idx to a safe value (0) to
              * prevent out-of-buffer reads.
              */
             correct &= ( ssl->in.msglen >= padlen + 1 );
-            correct &= ( padding_idx < MBEDTLS_SSL_MAX_CONTENT_LEN +
+            correct &= ( padding_idx < ssl->in.max_content_len +
                                        ssl->transform_in->maclen );
 
             padding_idx *= correct;
@@ -2093,7 +2093,7 @@ static int ssl_compress_buf( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
     }
 
-    ssl->out.msglen = MBEDTLS_SSL_BUFFER_LEN -
+    ssl->out.msglen = ssl->out.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
                       ssl->transform_out->ctx_deflate.avail_out;
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "after compression: msglen = %d, ",
@@ -2119,7 +2119,7 @@ static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
     if( len_pre == 0 )
         return( 0 );
 
-    memcpy( msg_pre, ssl->in.msg len_pre );
+    memcpy( msg_pre, ssl->in.msg, len_pre );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "before decompression: msglen = %d, ",
                    ssl->in.msglen ) );
@@ -2130,7 +2130,8 @@ static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
     ssl->transform_in->ctx_inflate.next_in = msg_pre;
     ssl->transform_in->ctx_inflate.avail_in = len_pre;
     ssl->transform_in->ctx_inflate.next_out = msg_post;
-    ssl->transform_in->ctx_inflate.avail_out = MBEDTLS_SSL_MAX_CONTENT_LEN;
+    ssl->transform_in->ctx_inflate.avail_out = ssl->out.max_content_len +
+                                                MBEDTLS_SSL_BUFFER_OVERHEAD;
 
     ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );
     if( ret != Z_OK )
@@ -2214,7 +2215,8 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
     }
 
-    if( nb_want > MBEDTLS_SSL_BUFFER_LEN - (size_t)( ssl->in.hdr - ssl->in.buf ) )
+    if( nb_want > ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
+                  (size_t)( ssl->in.hdr - ssl->in.buf ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "requesting more data than fits" ) );
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
@@ -2296,7 +2298,9 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
             ret = MBEDTLS_ERR_SSL_TIMEOUT;
         else
         {
-            len = MBEDTLS_SSL_BUFFER_LEN - ( ssl->in.hdr - ssl->in.buf );
+            len = ssl->in.max_content_len +
+                  + MBEDTLS_SSL_BUFFER_OVERHEAD -
+                  ( ssl->in.hdr - ssl->in.buf );
 
             if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
                 timeout = ssl->handshake->retransmit_timeout;
@@ -2943,7 +2947,7 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
         MBEDTLS_SSL_DEBUG_MSG( 2, ( "initialize reassembly, total length = %d",
                             msg_len ) );
 
-        if( ssl->in_hslen > MBEDTLS_SSL_MAX_CONTENT_LEN )
+        if( ssl->in_hslen > ssl->in.max_content_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake message too large" ) );
             return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
@@ -3047,7 +3051,7 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
         ssl->next_record_offset = new_remain - ssl->in.hdr;
         ssl->in.left = ssl->next_record_offset + remain_len;
 
-        if( ssl->in.left > MBEDTLS_SSL_BUFFER_LEN -
+        if( ssl->in.left > ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
                            (size_t)( ssl->in.hdr - ssl->in.buf ) )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "reassembled message too large for buffer" ) );
@@ -3421,7 +3425,7 @@ static int ssl_handle_possible_reconnect( mbedtls_ssl_context *ssl )
             ssl->conf->p_cookie,
             ssl->cli_id, ssl->cli_id_len,
             ssl->in.buf, ssl->in.left,
-            ssl->out.buf, MBEDTLS_SSL_MAX_CONTENT_LEN, &len );
+            ssl->out.buf, ssl->out.max_content_len, &len );
 
     MBEDTLS_SSL_DEBUG_RET( 2, "ssl_check_dtls_clihlo_cookie", ret );
 
@@ -3518,8 +3522,8 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
     }
 
     /* Check length against the size of our buffer */
-    if( ssl->in.msglen > MBEDTLS_SSL_BUFFER_LEN
-                         - (size_t)( ssl->in.msg- ssl->in.buf ) )
+    if( ssl->in.msglen > ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD
+                         - (size_t)( ssl->in.msg - ssl->in.buf ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3529,7 +3533,7 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
     if( ssl->transform_in == NULL )
     {
         if( ssl->in.msglen < 1 ||
-            ssl->in.msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
+            ssl->in.msglen > ssl->in.max_content_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3545,7 +3549,7 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
 
 #if defined(MBEDTLS_SSL_PROTO_SSL3)
         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 &&
-            ssl->in.msglen > ssl->transform_in->minlen + MBEDTLS_SSL_MAX_CONTENT_LEN )
+            ssl->in.msglen > ssl->transform_in->minlen + ssl->in.max_content_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3558,7 +3562,7 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
          */
         if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 &&
             ssl->in.msglen > ssl->transform_in->minlen +
-                             MBEDTLS_SSL_MAX_CONTENT_LEN + 256 )
+                             ssl->in.max_content_len + 256 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -3682,7 +3686,7 @@ static int ssl_prepare_record_content( mbedtls_ssl_context *ssl )
         MBEDTLS_SSL_DEBUG_BUF( 4, "input payload after decrypt",
                        ssl->in.msg, ssl->in.msglen );
 
-        if( ssl->in.msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
+        if( ssl->in.msglen > ssl->in.max_content_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
@@ -4274,10 +4278,10 @@ int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
     while( crt != NULL )
     {
         n = crt->raw.len;
-        if( n > MBEDTLS_SSL_MAX_CONTENT_LEN - 3 - i )
+        if( n > ssl->out.max_content_len - 3 - i )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate too large, %d > %d",
-                           i + 3 + n, MBEDTLS_SSL_MAX_CONTENT_LEN ) );
+                           i + 3 + n, ssl->out.max_content_len ) );
             return( MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE );
         }
 
@@ -5648,6 +5652,7 @@ int mbedtls_ssl_alloc_record_buf( mbedtls_ssl_context *ssl,
 	    /* if offt is in use, also fix it up */
 	    if (rec->offt)
 		    rec->offt = (rec->offt - rec->buf) + buf;
+            mbedtls_zeroize(rec->buf, rec->max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD);
 	    mbedtls_free(rec->buf);
     }
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "%s: realloc %s: %u -> %u\n", __func__,
@@ -6082,7 +6087,11 @@ int mbedtls_ssl_conf_psk( mbedtls_ssl_config *conf,
     if( psk_len > MBEDTLS_PSK_MAX_LEN )
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 
-    /* Identity len will be encoded on two bytes */
+    /* Identity len will be encoded on two bytes.
+     * This is also checked against the individual ssl buffer
+     * length before using in both ssl_write_client_key_exchange()
+     * for client and ssl_parse_client_psk_identity() for
+     * server. */
     if( ( psk_identity_len >> 16 ) != 0 ||
         psk_identity_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
     {
@@ -7404,13 +7413,15 @@ void mbedtls_ssl_free( mbedtls_ssl_context *ssl )
 
     if( ssl->out.buf != NULL )
     {
-        mbedtls_zeroize( ssl->out.buf, MBEDTLS_SSL_BUFFER_LEN );
+        mbedtls_zeroize( ssl->out.buf, ssl->out.max_content_len
+                                       + MBEDTLS_SSL_BUFFER_OVERHEAD );
         mbedtls_free( ssl->out.buf );
     }
 
     if( ssl->in.buf != NULL )
     {
-        mbedtls_zeroize( ssl->in.buf, MBEDTLS_SSL_BUFFER_LEN );
+        mbedtls_zeroize( ssl->in.buf, ssl->in.max_content_len
+                                      + MBEDTLS_SSL_BUFFER_OVERHEAD );
         mbedtls_free( ssl->in.buf );
     }
 

From 16455c3ed56fcbd1d588eed750266faa913d09a4 Mon Sep 17 00:00:00 2001
From: Andy Green <andy@warmcat.com>
Date: Tue, 12 Dec 2017 13:38:10 +0800
Subject: [PATCH 3/4] dynamic content length: mbedtls_ssl_confirm_content_len

This patch introduces mbedtls_ssl_confirm_content_len(), which
ensures that either the in or out record buffer is at least as
large enough for the given size.  If necessary, the buffer is
reallocated.

Length checks are preceded by calls to mbedtls_ssl_confirm_content_len()
attempting to resize the buffer being checked such that the check
will always pass.

mbedtls_ssl_confirm_content_len() will limit the allocation to 16384 +
the overhead constant if asked to allocate anything larger than 16384.

Initially, the buffer size is zero.

The in and out buffer sizes are handled separately.

The effect of this is to make the buffers dynamically "stretchy", such
that initially too small buffers simply adapt instead of fail out as
before.

For the test client, instead of a buffer allocation of 32KB + the overhead,
the client side only requires an allocation of 6625 bytes (1933 out and
4692 in).

Signed-off-by: Andy Green <andy@warmcat.com>
---
 include/mbedtls/ssl.h                |   9 +--
 include/mbedtls/ssl_internal.h       |   4 +-
 library/ssl_cli.c                    |  34 +++++---
 library/ssl_srv.c                    |  35 +++++++-
 library/ssl_tls.c                    | 151 +++++++++++++++++++++++++----------
 tests/suites/test_suite_ssl.function |   6 ++
 6 files changed, 182 insertions(+), 57 deletions(-)

diff --git a/include/mbedtls/ssl.h b/include/mbedtls/ssl.h
index ead330310..4d32fe11c 100644
--- a/include/mbedtls/ssl.h
+++ b/include/mbedtls/ssl.h
@@ -221,12 +221,9 @@
  * Maxium fragment length in bytes,
  * determines the size of each of the two internal I/O buffers.
  *
- * Note: the RFC defines the default size of SSL / TLS messages. If you
- * change the value here, other clients / servers may not be able to
- * communicate with you anymore. Only change this value if you control
- * both sides of the connection and have it reduced at both sides, or
- * if you're using the Max Fragment Length extension and you know all your
- * peers are using it too!
+ * If you set this to less than 16384, mbedTLS will initially size the
+ * buffers to the value given, and if it finds something larger is
+ * necessary, it will reallocate the buffer.  This involves a memcpy.
  */
 #if !defined(MBEDTLS_SSL_MAX_CONTENT_LEN)
 #define MBEDTLS_SSL_MAX_CONTENT_LEN         16384   /**< Size of the input / output buffer */
diff --git a/include/mbedtls/ssl_internal.h b/include/mbedtls/ssl_internal.h
index 2e83e24a2..962b45c9d 100644
--- a/include/mbedtls/ssl_internal.h
+++ b/include/mbedtls/ssl_internal.h
@@ -599,7 +599,9 @@ void mbedtls_ssl_dtls_replay_update( mbedtls_ssl_context *ssl );
 int mbedtls_ssl_alloc_record_buf( mbedtls_ssl_context *ssl,
                                   mbedtls_ssl_record *rec,
                                   size_t max_content_len );
-
+int mbedtls_ssl_confirm_content_len( mbedtls_ssl_context *ssl,
+                                     mbedtls_ssl_record *rec,
+                                     size_t content_len );
 /* constant-time buffer comparison */
 static inline int mbedtls_ssl_safer_memcmp( const void *a, const void *b, size_t n )
 {
diff --git a/library/ssl_cli.c b/library/ssl_cli.c
index 47fb9459d..b59f794a2 100644
--- a/library/ssl_cli.c
+++ b/library/ssl_cli.c
@@ -73,6 +73,10 @@ static void ssl_write_hostname_ext( mbedtls_ssl_context *ssl,
 
     hostname_len = strlen( ssl->hostname );
 
+    if( mbedtls_ssl_confirm_content_len( ssl, &ssl->out, buf - ssl->out.buf  +
+                                           hostname_len + 9 ) )
+        return;
+
     if( end < p || (size_t)( end - p ) < hostname_len + 9 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
@@ -442,7 +446,7 @@ static void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
                                                size_t *olen )
 {
     unsigned char *p = buf;
-    const unsigned char *end = ssl->out.msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
+    const unsigned char *end = ssl->out.msg + ssl->out.max_content_len;
 
     *olen = 0;
 
@@ -720,7 +724,7 @@ static int ssl_generate_random( mbedtls_ssl_context *ssl )
 static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
 {
     int ret;
-    size_t i, n, olen, ext_len = 0;
+    size_t i, n, olen, ext_len = 0, pofs;
     unsigned char *buf;
     unsigned char *p, *q;
     unsigned char offer_compress;
@@ -750,6 +754,10 @@ static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
     }
 
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out, MBEDTLS_SSL_BUFFER_MIN + 1024 );
+    if( ret )
+        return( ret );
+
     /*
      *     0  .   0   handshake type
      *     1  .   3   handshake length
@@ -967,6 +975,8 @@ static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
         *p++ = MBEDTLS_SSL_COMPRESS_NULL;
     }
 
+    pofs = p - ssl->out.buf;
+
     // First write extensions, then the total length
     //
 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
@@ -989,9 +999,10 @@ static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
 
 #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
     defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
+    /* 6 bytes per */
     ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len, &olen );
     ext_len += olen;
-
+    /* 6 bytes per */
     ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
     ext_len += olen;
 #endif
@@ -1025,14 +1036,19 @@ static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
     ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );
     ext_len += olen;
 #endif
-
 #if defined(MBEDTLS_SSL_SESSION_TICKETS)
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out, pofs + 2 + ext_len +
+    		ssl->session_negotiate->ticket_len + 4 + 3 );
+    if( ret )
+        return ret;
+    p = ssl->out.buf + pofs;
     ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
     ext_len += olen;
 #endif
 
-    /* olen unused if all extensions are disabled */
+    /* unused if all extensions are disabled */
     ((void) olen);
+    ((void) pofs);
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello, total extension length: %d",
                    ext_len ) );
@@ -1044,7 +1060,7 @@ static int ssl_write_client_hello( mbedtls_ssl_context *ssl )
         p += ext_len;
     }
 
-    ssl->out.msglen  = p - buf;
+    ssl->out.msglen  = p - ssl->out.msg;
     ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
     ssl->out.msg[0]  = MBEDTLS_SSL_HS_CLIENT_HELLO;
 
@@ -1456,8 +1472,6 @@ static int ssl_parse_server_hello( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse server hello" ) );
 
-    buf = ssl->in.msg;
-
     if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
     {
         /* No alert on a read error. */
@@ -1493,6 +1507,8 @@ static int ssl_parse_server_hello( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
+    buf = ssl->in.msg;
+
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
     {
@@ -1532,7 +1548,7 @@ static int ssl_parse_server_hello( mbedtls_ssl_context *ssl )
      * 38+n . 39+n  extensions length (optional)
      * 40+n .  ..   extensions
      */
-    buf += mbedtls_ssl_hs_hdr_len( ssl );
+    buf = ssl->in.msg + mbedtls_ssl_hs_hdr_len( ssl );
 
     MBEDTLS_SSL_DEBUG_BUF( 3, "server hello, version", buf + 0, 2 );
     mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,
diff --git a/library/ssl_srv.c b/library/ssl_srv.c
index 96a3135b1..db3db1e81 100644
--- a/library/ssl_srv.c
+++ b/library/ssl_srv.c
@@ -1257,6 +1257,10 @@ static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
     }
 
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out, MBEDTLS_SSL_BUFFER_MIN);
+    if( ret )
+        return( ret );
+
     /* For DTLS if this is the initial handshake, remember the client sequence
      * number to use it in our next message (RFC 6347 4.2.1) */
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
@@ -2379,6 +2383,10 @@ static int ssl_write_server_hello( mbedtls_ssl_context *ssl )
     size_t olen, ext_len = 0, n;
     unsigned char *buf, *p;
 
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out, MBEDTLS_SSL_BUFFER_MIN + 1024 );
+    if( ret )
+        return( ret );
+
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello" ) );
 
 #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
@@ -3208,8 +3216,16 @@ static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
             n += 2;
         }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
+	len = p - ssl->out.buf;
+        ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out,
+                                               ( p + 4 - ssl->out.buf ) +
+                                               mbedtls_pk_get_len(
+						     mbedtls_ssl_own_key( ssl ) ) );
+        if( ret )
+            return( ret );
+	p = ssl->out.buf + len;
 
-        if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,
+	if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,
                         p + 2 , &signature_len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_sign", ret );
@@ -3949,6 +3965,23 @@ static int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write new session ticket" ) );
 
+    if( ssl && ssl->session_negotiate && ssl->session_negotiate->peer_cert ) {
+        /*
+	 * We need enough space to cover:
+	 *
+	 *  - the peer cert itself
+	 *  - at least 4 bytes for key_name, 12 for IV, 2 for len, 16 for tag
+	 *  - 10 for the header
+	 *  - the gap between the buffer and message start
+	 *  - the session struct
+	 */
+        ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out,
+            ssl->session_negotiate->peer_cert->raw.len + 4 + 12 + 2 + 16 + 10 +
+	        (ssl->out.msg - ssl->out.buf) + sizeof( mbedtls_ssl_session ) );
+        if( ret )
+            return( ret );
+    }
+
     ssl->out.msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
     ssl->out.msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
 
diff --git a/library/ssl_tls.c b/library/ssl_tls.c
index 4b99012f8..92d1185a4 100644
--- a/library/ssl_tls.c
+++ b/library/ssl_tls.c
@@ -2084,7 +2084,8 @@ static int ssl_compress_buf( mbedtls_ssl_context *ssl )
     ssl->transform_out->ctx_deflate.next_in = msg_pre;
     ssl->transform_out->ctx_deflate.avail_in = len_pre;
     ssl->transform_out->ctx_deflate.next_out = msg_post;
-    ssl->transform_out->ctx_deflate.avail_out = MBEDTLS_SSL_BUFFER_LEN;
+    ssl->transform_out->ctx_deflate.avail_out = ssl->out.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
+                                                  (ssl->out.msg - ssl->out.buf);
 
     ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );
     if( ret != Z_OK )
@@ -2130,8 +2131,9 @@ static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
     ssl->transform_in->ctx_inflate.next_in = msg_pre;
     ssl->transform_in->ctx_inflate.avail_in = len_pre;
     ssl->transform_in->ctx_inflate.next_out = msg_post;
-    ssl->transform_in->ctx_inflate.avail_out = ssl->out.max_content_len +
-                                                MBEDTLS_SSL_BUFFER_OVERHEAD;
+    ssl->transform_in->ctx_inflate.avail_out = ssl->in.max_content_len +
+                                                MBEDTLS_SSL_BUFFER_OVERHEAD -
+						 (ssl->in.msg - ssl->in.buf);
 
     ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );
     if( ret != Z_OK )
@@ -2215,6 +2217,11 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
     }
 
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->in, nb_want +
+		              (size_t)( ssl->in.hdr - ssl->in.buf ) + 1024 );
+    if( ret )
+	    return( ret );
+
     if( nb_want > ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
                   (size_t)( ssl->in.hdr - ssl->in.buf ) )
     {
@@ -2372,6 +2379,11 @@ int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
         {
             len = nb_want - ssl->in.left;
 
+            ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->in, ssl->in.left + len );
+            if( ret )
+	            return( ret );
+
+
             if( ssl_check_timer( ssl ) != 0 )
                 ret = MBEDTLS_ERR_SSL_TIMEOUT;
             else
@@ -2813,6 +2825,11 @@ int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
 #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
     if( !done )
     {
+        ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out, ssl->out.msglen +
+					       mbedtls_ssl_hdr_len( ssl ));
+        if( ret )
+	        return( ret );
+
         ssl->out.hdr[0] = (unsigned char) ssl->out.msgtype;
         mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
                            ssl->conf->transport, ssl->out.hdr + 1 );
@@ -2930,6 +2947,8 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
     unsigned char *msg, *bitmask;
     size_t frag_len, frag_off;
     size_t msg_len = ssl->in_hslen - 12; /* Without headers */
+    size_t required;
+    int ret;
 
     if( ssl->handshake == NULL )
     {
@@ -2947,6 +2966,10 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
         MBEDTLS_SSL_DEBUG_MSG( 2, ( "initialize reassembly, total length = %d",
                             msg_len ) );
 
+        ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->in, ssl->in_hslen);
+        if( ret )
+	        return( ret );
+
         if( ssl->in_hslen > ssl->in.max_content_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake message too large" ) );
@@ -3051,8 +3074,13 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
         ssl->next_record_offset = new_remain - ssl->in.hdr;
         ssl->in.left = ssl->next_record_offset + remain_len;
 
-        if( ssl->in.left > ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
-                           (size_t)( ssl->in.hdr - ssl->in.buf ) )
+        required = ssl->in.left + (size_t)( ssl->in.hdr - ssl->in.buf );
+
+        ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->in, required );
+        if( ret )
+	        return( ret );
+
+        if( required > (size_t)(ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD) )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "reassembled message too large for buffer" ) );
             return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
@@ -3151,7 +3179,7 @@ int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
     /* With TLS we don't handle fragmentation (for now) */
     if( ssl->in.msglen < ssl->in_hslen )
     {
-        MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLS handshake fragmentation not supported" ) );
+        MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLS handshake fragmentation not supported (msglen %d, in_hslen %d)", ssl->in.msglen, ssl->in_hslen ) );
         return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
     }
 
@@ -3476,7 +3504,7 @@ static int ssl_handle_possible_reconnect( mbedtls_ssl_context *ssl )
  */
 static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
 {
-    int major_ver, minor_ver;
+    int major_ver, minor_ver, ret;
 
     MBEDTLS_SSL_DEBUG_BUF( 4, "input record header", ssl->in.hdr, mbedtls_ssl_hdr_len( ssl ) );
 
@@ -3521,21 +3549,18 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
         return( MBEDTLS_ERR_SSL_INVALID_RECORD );
     }
 
-    /* Check length against the size of our buffer */
-    if( ssl->in.msglen > ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD
-                         - (size_t)( ssl->in.msg - ssl->in.buf ) )
-    {
-        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
-        return( MBEDTLS_ERR_SSL_INVALID_RECORD );
-    }
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->in,
+                                           (size_t)( ssl->in.msg - ssl->in.buf ) + ssl->in.msglen );
+    if( ret )
+	    return( ret );
 
     /* Check length against bounds of the current transform and version */
     if( ssl->transform_in == NULL )
     {
         if( ssl->in.msglen < 1 ||
-            ssl->in.msglen > ssl->in.max_content_len )
+            ssl->in.msglen > (size_t)(ssl->in.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD) )
         {
-            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
+            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length %d vs %d ", ssl->in.msglen, ssl->in.max_content_len ) );
             return( MBEDTLS_ERR_SSL_INVALID_RECORD );
         }
     }
@@ -4278,7 +4303,13 @@ int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
     while( crt != NULL )
     {
         n = crt->raw.len;
-        if( n > ssl->out.max_content_len - 3 - i )
+
+        ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out,
+                                               n + 3 + i);
+        if( ret )
+                return( ret );
+
+        if( n > ssl->out.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD - 3 - i )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate too large, %d > %d",
                            i + 3 + n, ssl->out.max_content_len ) );
@@ -5622,7 +5653,7 @@ void mbedtls_ssl_init( mbedtls_ssl_context *ssl )
  * non-null ssl->*buf
  */
 int mbedtls_ssl_alloc_record_buf( mbedtls_ssl_context *ssl,
-		                  mbedtls_ssl_record *rec,
+		                          mbedtls_ssl_record *rec,
                                   size_t max_content_len )
 {
     size_t len, min;
@@ -5644,6 +5675,7 @@ int mbedtls_ssl_alloc_record_buf( mbedtls_ssl_context *ssl,
 
     buf = mbedtls_calloc( 1, len );
     if( !buf ) {
+        MBEDTLS_SSL_DEBUG_MSG( 2, ( "%s: alloc of %lu failed", __func__, (long)len ) );
         return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
     }
 
@@ -5652,36 +5684,44 @@ int mbedtls_ssl_alloc_record_buf( mbedtls_ssl_context *ssl,
 	    /* if offt is in use, also fix it up */
 	    if (rec->offt)
 		    rec->offt = (rec->offt - rec->buf) + buf;
-            mbedtls_zeroize(rec->buf, rec->max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD);
+        mbedtls_zeroize(rec->buf, rec->max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD);
 	    mbedtls_free(rec->buf);
     }
-    MBEDTLS_SSL_DEBUG_MSG( 2, ( "%s: realloc %s: %u -> %u\n", __func__,
+    MBEDTLS_SSL_DEBUG_MSG( 2, ( "%s: realloc %s: %u -> (%u + %u)\n", __func__,
 			   rec == &ssl->in ? "in" : "out",
 			   (unsigned int)rec->max_content_len,
-			   (unsigned int)max_content_len ) );
-
-    rec->buf = buf;
-    rec->max_content_len = max_content_len;
+			   (unsigned int)max_content_len, MBEDTLS_SSL_BUFFER_OVERHEAD ) );
 
+    if( !rec->buf ) {
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
-    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
-    {
-        rec->hdr = buf;
-        rec->ctr = buf +  3;
-        rec->len = buf + 11;
-        rec->iv  = buf + 13;
-        rec->msg = buf + 13;
-    }
-    else
+        if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
+        {
+            rec->hdr = buf;
+            rec->ctr = buf +  3;
+            rec->len = buf + 11;
+            rec->iv  = buf + 13;
+            rec->msg = buf + 13;
+        }
+        else
 #endif
-    {
-        rec->ctr = buf;
-        rec->hdr = buf +  8;
-        rec->len = buf + 11;
-        rec->iv  = buf + 13;
-        rec->msg = buf + 13;
+        {
+            rec->ctr = buf;
+            rec->hdr = buf +  8;
+            rec->len = buf + 11;
+            rec->iv  = buf + 13;
+            rec->msg = buf + 13;
+        }
+    } else {
+        rec->ctr = rec->ctr - rec->buf + buf;
+        rec->hdr = rec->hdr - rec->buf + buf;
+        rec->len = rec->len - rec->buf + buf;
+        rec->iv = rec->iv - rec->buf + buf;
+        rec->msg = rec->msg - rec->buf + buf;
     }
 
+    rec->buf = buf;
+    rec->max_content_len = max_content_len;
+
     return( 0 );
 }
 
@@ -5701,6 +5741,30 @@ int mbedtls_ssl_setup( mbedtls_ssl_context *ssl,
     return( 0 );
 }
 
+/*
+ * if content_len is bigger than the existing buffer can
+ * handle, grow it.
+ *
+ * Notice that the amount actually allocated is content_len +
+ * MBEDTLS_SSL_BUFFER_OVERHEAD.  rec->max_content_len is
+ * set to the length without MBEDTLS_SSL_BUFFER_OVERHEAD.
+ */
+int mbedtls_ssl_confirm_content_len( mbedtls_ssl_context *ssl,
+                                     mbedtls_ssl_record *rec,
+                                     size_t content_len )
+{
+    if( content_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
+	    content_len = MBEDTLS_SSL_MAX_CONTENT_LEN;
+
+    if( rec->buf &&
+        content_len <= (size_t)rec->max_content_len )
+	    return( 0 );
+
+    /* we have to either create or expand the buffer to cope with this... */
+
+    return( mbedtls_ssl_alloc_record_buf(ssl, rec, content_len ) );
+}
+
 /*
  * Reset an initialized and used SSL context for re-use while retaining
  * all application-set variables, function pointers and data.
@@ -6802,10 +6866,13 @@ int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
 {
     int ret;
     size_t n;
-
     if( ssl == NULL || ssl->conf == NULL )
         return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
 
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->in, ssl->in.msglen );
+    if( ret )
+	    return( ret );
+
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read" ) );
 
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
@@ -7230,6 +7297,10 @@ int mbedtls_ssl_write( mbedtls_ssl_context *ssl, const unsigned char *buf, size_
         }
     }
 
+    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out, len );
+    if( ret )
+        return( ret );
+
 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
     ret = ssl_write_split( ssl, buf, len );
 #else
diff --git a/tests/suites/test_suite_ssl.function b/tests/suites/test_suite_ssl.function
index 61799c337..3954dcd20 100644
--- a/tests/suites/test_suite_ssl.function
+++ b/tests/suites/test_suite_ssl.function
@@ -24,6 +24,12 @@ void ssl_dtls_replay( char *prevs, char *new, int ret )
                  MBEDTLS_SSL_PRESET_DEFAULT ) == 0 );
     TEST_ASSERT( mbedtls_ssl_setup( &ssl, &conf ) == 0 );
 
+    /* allocation for the ssl buffers is normally deferred until
+     * first use.  For the test, force an allocation of the in
+     * buffer.
+     */
+    TEST_ASSERT( mbedtls_ssl_confirm_content_len( &ssl, &ssl.in, 1024) == 0 );
+
     /* Read previous record numbers */
     for( ; end_prevs - prevs >= 13; prevs += 13 )
     {

From e5230d1ccd453bb3e7e5de85fd97f5ed90d44ce3 Mon Sep 17 00:00:00 2001
From: Andy Green <andy@warmcat.com>
Date: Thu, 14 Dec 2017 06:58:35 +0800
Subject: [PATCH 4/4] dynamic content length: support in compression and
 decompression

In the case of decompression, the size of the decompressed
image can't be predicted, although we know from the application
it will be less than the max fragment size (16384).

Actually compression has the same issue, it is not know what the
final size of the compressed fragment will be, and it may be
larger than the original.

This patch adapts compression and decompression to reallocate the
output buffer in the case it is not already big enough.

Signed-off-by: Andy Green <andy@warmcat.com>
---
 library/ssl_tls.c | 110 +++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 72 insertions(+), 38 deletions(-)

diff --git a/library/ssl_tls.c b/library/ssl_tls.c
index 92d1185a4..3806c853c 100644
--- a/library/ssl_tls.c
+++ b/library/ssl_tls.c
@@ -2063,17 +2063,16 @@ static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
  */
 static int ssl_compress_buf( mbedtls_ssl_context *ssl )
 {
-    int ret;
-    unsigned char *msg_post = ssl->out.msg;
-    size_t len_pre = ssl->out.msglen;
-    unsigned char *msg_pre = ssl->compress_buf;
+    unsigned int pending;
+    size_t avail_out;
+    int ret, bits;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> compress buf" ) );
 
-    if( len_pre == 0 )
+    if( ssl->out.msglen == 0 )
         return( 0 );
 
-    memcpy( msg_pre, ssl->out.msg, len_pre );
+    memcpy( ssl->compress_buf, ssl->out.msg, ssl->out.msglen );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "before compression: msglen = %d, ",
                    ssl->out.msglen ) );
@@ -2081,21 +2080,41 @@ static int ssl_compress_buf( mbedtls_ssl_context *ssl )
     MBEDTLS_SSL_DEBUG_BUF( 4, "before compression: output payload",
                    ssl->out.msg, ssl->out.msglen );
 
-    ssl->transform_out->ctx_deflate.next_in = msg_pre;
-    ssl->transform_out->ctx_deflate.avail_in = len_pre;
-    ssl->transform_out->ctx_deflate.next_out = msg_post;
-    ssl->transform_out->ctx_deflate.avail_out = ssl->out.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
-                                                  (ssl->out.msg - ssl->out.buf);
+    ssl->transform_out->ctx_deflate.next_in = ssl->compress_buf;
+    ssl->transform_out->ctx_deflate.avail_in = ssl->out.msglen;
+    ssl->out.msglen = 0;
 
-    ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );
-    if( ret != Z_OK )
-    {
-        MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform compression (%d)", ret ) );
-        return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
-    }
+    /*
+     * "compression" isn't guaranteed to result in something smaller...
+     * it's possible we have to increase the out buf size to write all
+     * the deflated data for the payload
+     */
+    do {
+        ssl->transform_out->ctx_deflate.next_out = ssl->out.msg + ssl->out.msglen;
+        ssl->transform_out->ctx_deflate.avail_out = ssl->out.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
+                                                  (ssl->out.msg - ssl->out.buf) - ssl->out.msglen;
+	avail_out = ssl->transform_out->ctx_deflate.avail_out;
 
-    ssl->out.msglen = ssl->out.max_content_len + MBEDTLS_SSL_BUFFER_OVERHEAD -
-                      ssl->transform_out->ctx_deflate.avail_out;
+        ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );
+        if( ret != Z_OK && ret != Z_BUF_ERROR )
+        {
+            MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform compression (%d)", ret ) );
+            return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
+        }
+
+	ssl->out.msglen += avail_out - ssl->transform_out->ctx_deflate.avail_out;
+
+	/* check if we still have more compresssed to write */
+	deflatePending(&ssl->transform_out->ctx_deflate, &pending, &bits);
+        if( ssl->transform_out->ctx_deflate.avail_in ||
+            ( !ssl->transform_out->ctx_deflate.avail_out && ( pending || bits ) ) ) {
+		/* we have to increase the out buf and continue */
+	    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->out, ssl->out.max_content_len + 1024);
+            if( ret )
+	         return( ret );
+	    continue;
+        }
+    } while( 0 );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "after compression: msglen = %d, ",
                    ssl->out.msglen ) );
@@ -2111,16 +2130,14 @@ static int ssl_compress_buf( mbedtls_ssl_context *ssl )
 static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
 {
     int ret;
-    unsigned char *msg_post = ssl->in.msg;
-    size_t len_pre = ssl->in.msglen;
-    unsigned char *msg_pre = ssl->compress_buf;
+    size_t avail_out;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> decompress buf" ) );
 
-    if( len_pre == 0 )
+    if( ssl->in.msglen == 0 )
         return( 0 );
 
-    memcpy( msg_pre, ssl->in.msg, len_pre );
+    memcpy( ssl->compress_buf, ssl->in.msg, ssl->in.msglen );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "before decompression: msglen = %d, ",
                    ssl->in.msglen ) );
@@ -2128,22 +2145,39 @@ static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
     MBEDTLS_SSL_DEBUG_BUF( 4, "before decompression: input payload",
                    ssl->in.msg, ssl->in.msglen );
 
-    ssl->transform_in->ctx_inflate.next_in = msg_pre;
-    ssl->transform_in->ctx_inflate.avail_in = len_pre;
-    ssl->transform_in->ctx_inflate.next_out = msg_post;
-    ssl->transform_in->ctx_inflate.avail_out = ssl->in.max_content_len +
-                                                MBEDTLS_SSL_BUFFER_OVERHEAD -
-						 (ssl->in.msg - ssl->in.buf);
+    ssl->transform_in->ctx_inflate.next_in = ssl->compress_buf;
+    ssl->transform_in->ctx_inflate.avail_in = ssl->in.msglen;
+    ssl->in.msglen = 0;
+
+    do {
+        ssl->transform_in->ctx_inflate.next_out = ssl->in.msg + ssl->in.msglen;
+        ssl->transform_in->ctx_inflate.avail_out = ssl->in.max_content_len +
+                                                   MBEDTLS_SSL_BUFFER_OVERHEAD -
+                                                   (ssl->in.msg - ssl->in.buf) - ssl->in.msglen;
+	avail_out = ssl->transform_in->ctx_inflate.avail_out;
 
-    ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );
-    if( ret != Z_OK )
-    {
-        MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform decompression (%d)", ret ) );
-        return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
-    }
+        ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );
+        if( ret != Z_OK && ret != Z_BUF_ERROR )
+        {
+            MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform decompression (%d)", ret ) );
+            return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
+        }
 
-    ssl->in.msglen = MBEDTLS_SSL_MAX_CONTENT_LEN -
-                     ssl->transform_in->ctx_inflate.avail_out;
+	if( avail_out == ssl->transform_in->ctx_inflate.avail_out )
+		/* we explicitly completed the inflate action */
+		break;
+
+        ssl->in.msglen += avail_out - ssl->transform_in->ctx_inflate.avail_out;
+	/* check if we still have more decompressed to write */
+        if( ssl->transform_in->ctx_deflate.avail_in ||
+            !ssl->transform_in->ctx_deflate.avail_out ) {
+		/* we have to increase the out buf and continue */
+	    ret = mbedtls_ssl_confirm_content_len( ssl, &ssl->in, ssl->in.max_content_len + 1024);
+            if( ret )
+	         return( ret );
+        }
+	/* we go around anyway, so inflate() can confirm nothing left and exit */
+    } while( 1 );
 
     MBEDTLS_SSL_DEBUG_MSG( 3, ( "after decompression: msglen = %d, ",
                    ssl->in.msglen ) );

